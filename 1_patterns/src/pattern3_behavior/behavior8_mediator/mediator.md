# Mediator

## Посредник

**Паттерн Посредник (Mediator)** — это поведенческий паттерн проектирования, который определяет объект-посредник для
инкапсуляции взаимодействий между множеством объектов. Посредник способствует слабой связанности, удерживая объекты от
необходимости явно ссылаться друг на друга, что упрощает сопровождение и расширение системы.

#### Основная идея

Вместо того чтобы объекты взаимодействовали напрямую друг с другом, они общаются через посредника. Посредник управляет
логикой взаимодействия, что позволяет изменять и расширять взаимодействия без изменения самих объектов.

#### Применение

Паттерн Посредник рекомендуется использовать в следующих случаях:

- **Много взаимосвязанных классов:** Когда классы взаимодействуют между собой, создавая сложную сеть зависимостей.
- **Снижение связанности:** Когда необходимо уменьшить количество прямых зависимостей между классами.
- **Централизация управления взаимодействиями:** Когда нужно централизовать логику взаимодействия для упрощения
  сопровождения и расширения системы.
- **Гибкость в изменении взаимодействий:** Когда требуется легко менять или добавлять новые виды взаимодействий между
  объектами.

### Реализация

1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например,
   чтобы повторно использовать их код в другой программе.
2. Создайте общий интерфейс Посредников и опишите в нём методы для взаимодействия с Компонентами. В простейшем случае
   достаточно одного метода для получения оповещений от компонентов.
   Этот интерфейс необходим, если вы хотите повторно
   использовать классы компонентов для других задач. В этом
   случае, всё, что нужно сделать — это создать новый класс
   конкретного посредника.
3. Реализуйте этот интерфейс в классе Конкретного посредника. Поместите в него поля, которые будут содержать ссылки на
   все объекты компонентов.
4. Вы можете пойти дальше и переместить код создания компонентов в класс Конкретного посредника, превратив его в фабрику
5. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобней всего установить, подавая
   посредника в параметры конструктора компонентов.
6. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, а не методы других компонентов. С
   другой стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение.

### Примеры

- В паттерне Model-View-Controller, controller является посредником между view/use и model.

#### Примеры из стандратной Java библиотеки

- В ```javax.swing``` система управления событиями может рассматриваться как реализация паттерна Посредник.
  Например, ```EventDispatcher``` координирует события между различными компонентами GUI.

#### [Пример](code%2Fexample2_new_chatroom%2FMain.java) с чат комнатой

**Цель:** Создать простую модель чат-комнаты, где участники общаются друг с другом через посредника, что снижает
связанность между ними.

---

**Посредник (```ChatRoom```):** Управляет регистрацией пользователей и распределением сообщений между ними.

```java
public interface Mediator {
    void register(User user);
    void sendMessage(String message, User user);
}
```

```java
public class ChatRoom implements Mediator {
    private List<User> users;

    public ChatRoom() {
        users = new ArrayList<>();
    }

    @Override
    public void register(User user) {
        if(!users.contains(user)){
            users.add(user);
            user.setMediator(this);
            System.out.println(user.getName() + " присоединился к чат-комнате.");
        }
    }

    @Override
    public void sendMessage(String message, User sender) {
        for(User user : users){
            // Не отправлять сообщение отправителю
            if(user != sender){
                user.receive(message);
            }
        }
    }
}
```

---

**Коллеги (```User```):** Общаются через посредника, отправляя и получая сообщения.

```java
public class User {
    private String name;
    private Mediator mediator;

    public User(String name){
        this.name = name;
    }

    public void setMediator(Mediator mediator){
        this.mediator = mediator;
    }

    public String getName(){
        return name;
    }

    public void send(String message){
        System.out.println(this.name + " отправил сообщение: " + message);
        mediator.sendMessage(message, this);
    }

    public void receive(String message){
        System.out.println(this.name + " получил сообщение: " + message);
    }
}
```

---

```java
public class Main {
    public static void main(String[] args) {
        Mediator chatRoom = new ChatRoom();

        User alice = new User("Alice");
        User bob = new User("Bob");
        User charlie = new User("Charlie");

        chatRoom.register(alice);
        chatRoom.register(bob);
        chatRoom.register(charlie);

        alice.send("Привет всем!");
        bob.send("Привет, Alice!");
        charlie.send("Здравствуйте!");
    }
}
```

---

### Плюсы данного паттерна

- Устраняет зависимости между компонентами, позволяя повторно их использовать.
- Упрощает взаимодействие между компонентами.
- Централизует управление в одном месте.

### Недостатки данного паттерна

- Посредник может сильно раздуться и легко превратиться в God-класс.

### Между **Mediator** и **Observer** по началу сложно уловить разницу.

#### Если по-умному, то их различие в следующем:

Паттерн **Observer** уменьшает связанность за счёт обращения зависимостей. Он хорошо применим, когда есть несколько
источников событий и много слушателей, которые добавляются динамически. Другим хорошим примером использования этого
паттерна является реактивное программирование, когда изменение состояния одного объекта приводит к изменению состояния
всех зависимых от него объектов и так далее.

Паттерн **Mediator** уменьшает связанность системы за счёт того, что все зависимости уходят в один класс медиатор, а все
остальные классы становятся независимы и отвечают только за логику, которую они выполняют. Таким образом, добавление
новых классов становится проще, но с каждым новым классом логика медиатора сильно усложняется.

#### Если пытаться объяснить проще:

Паттерн **Observer** нужен когда мы хотим, чтобы на изменение одного объекта реагировало множество (даже если множество
состоит из 1ого) других объектов. При этом мы не хотим, что этот объект-издатель (на изменение состояния которого мы
реагируем) знал о подписчиках (объектах, которые реагируют на его изменение). *Связь одностроняя, подписичик знают об
издателе, но издатель не знает о подписчиках*

Паттерн **Mediator** позволяет вынести обоюдные связи множества объектов в отдельный класс. При этом все объекты будут
знать только о mediator'е, но не друг о друге. То есть в данном случае mediator можно представить в виде шины общения.
*Все знают о mediator'e, внутри него уже происходит связь, причем в основном двустороняя*.

### Источники

- Design Patterns with Java: Mediator
- Введение в паттерны проектирования: Посредник