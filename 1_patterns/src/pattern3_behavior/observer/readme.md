<h1 align="center">
   Observer
</h1>
<h3 align="center">
   Наблюдатель
</h3>

**Наблюдатель** — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним
объектам следить и реагировать на события, происходящие в других объектах.

<h3 align="center">
   Применимость
</h3>

- Когда при изменении состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд какие именно
  объекты должны отреагировать.
- Когда одни объекты должны наблюдать за другими, но только в определённых случаях.

<h3 align="center">
   Реализация
</h3>

1. Разбейте вашу функциональность на две части:   независимое ядро и опциональные зависимые части. Независимое ядро
   станет издателем. Зависимые части станут подписчиками.
2. Создайте интерфейс подписчиков. Обычно, в нём достаточно определить единственный метод оповещения.
3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать
   только с общим интерфейсом подписчиков.
4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый
   очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.
5. Создайте классы конкретных издателей. Реализуйте их так, чтобы при каждом изменении состояния, они слали оповещения
   всем своим подписчикам.
6. Реализуйте метод оповещения в конкретных подписчиках. Издатель может отправлять какие-то данные вместе с
   оповещением (например, в параметрах). Возможен и другой вариант, когда подписчик, получив оповещение, сам берёт из
   объекта издателя нужные данные. Но при этом подписчик привяжет себя к конкретному классу издателя.
7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

<h3 align="center">
   Observer UML-диаграмма
</h3>

![diagram.png](diagram.png)

<h3>Плюсы</h3>

- Издатель не зависит от конкретных классов подписчиков.
- Вы можете подписывать и отписывать получателей на лету.
- Реализует принцип открытости/закрытости.

<h3>Минусы</h3>

- Наблюдатели оповещаются в случайном порядке.
- Имеет проблемы при работе в мультипоточности. Поток-безопасные реализации паттерна представлены в книге Design
  Patterns with Java.

<h3 align="center">
   Примеры
</h3>

- В стандартной библиотеке Java есть класс и интерфейс Observer и Observable, но они считают устаревшими так как не
  являются потоко-безопасными. В качестве потоко-безопасной реализации в дальнейшем были добавлены интерфейсы Publisher
  и Subscribe.
- Одной из реализацией Наблюдателя является паттерн Издатель-Подписчик (вообще кто-то говорит, что это одно и тоже,
  кто-то говорит, что одно это частная реализация второго - не важно).

  В частности в библиотеке Qt для разработки граф. интерфейса на С++ для пробрасывания событий между компонентами
  используется паттерн Издатель-Подписчик.

- [Baeldung: The Observer Pattern in Java](https://www.baeldung.com/java-observer-pattern)
- [Пример с церковью и прихожанами.](code)

<h5>
    Замечание
</h5>

Для сокращения написанного кода, можно посмотреть в сторону класса ```PropertyChangeListener``` стандартной библиотеки
Java. Использование данного класса позволяет сократить код для реализация паттерна Observer.

При реализации данного паттерна связь Публикатора и Подписчиков также можно вынести в отдельный класс. В таком виде
паттерн будет сильно похож на медиатор, но у них есть ключевое различие: в **Mediator** четко задается получать, в то
время как в **Observer** публикатор просто сообщает о своем измении состоянии и не важно кто на это отреагирует и
отреагирует ли кто-то вообще.

<h3 align="center">
   Источники
</h3>

- Design Patterns with
  Java: [Observer](books/Olaf%20Musch%20EN.pdf)
- Введение в паттерны
  проектирования: [Наблюдатель](books/Alexander%20Shvets%20RU.pdf)