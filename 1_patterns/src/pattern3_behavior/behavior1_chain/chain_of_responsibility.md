# Chain of Responsibility

## Цепочка обязоностей

**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы
последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит
ли передавать запрос дальше по цепи.

Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения
в объекты. В нашем случае, каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса,
над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. Паттерн предлагает выстроить несколько обработчиков в цепь. Каждый обработчик будет
хранить ссылку на следующий обработчик в цепи. А при получении запроса, он не только обработает его, но и передаст
следующему объекту. Таким образом, можно сформировать длинную цепочкуобработчиков и передавать запрос в первый из них,
зная о том, что вся цепочка сможет его обработать в определённом порядке. И последний штрих. Обработчик необязательно
должен передавать запрос дальше. Причём эта особенность может быть использована по-разному.

#### Основная идея

Основная идея паттерна заключается в том, чтобы создать цепочку объектов-обработчиков, каждый из которых знает о
следующем в цепочке. Когда приходит запрос, он передается по цепочке до тех пор, пока один из обработчиков не примет
его.

#### Применение

Паттерн Цепочка Обязанностей рекомендуется использовать в следующих случаях:

- **Неизвестно, какой объект обработает запрос:** Когда неясно, какой из объектов в цепочке сможет обработать запрос,
  или когда требуется, чтобы несколько объектов могли обработать запрос.
- **Обработка запросов без жесткой связи:** Когда необходимо избежать жесткой связки между отправителем запроса и его
  получателями.
- **Динамическое добавление обработчиков:** Когда требуется возможность добавления или удаления обработчиков в цепочке
  во время выполнения программы.

### Реализация

1. Создайте интерфейс обработчика и опишите в нём основной метод обработки. Продумайте, в каком виде клиент должен
   передавать данные запроса в обработчик. Самый гибкий способ — превратить данные запроса в объект и передавать его
   целиком через параметры метода обработчика.
2. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не дублировать реализацию метода получения
   следующего обработчика во всех конкретных обработчиках.

   Добавьте в базовый обработчик поле для хранения ссылки на
   следующий объект цепочки. Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты
   обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер
   для поля.

   Реализуйте здесь метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его
   наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по
   цепи, обратившись к родительской реализации метода.
3. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. При получении
   запроса каждый обработчик должен решить:
    - Может он обработать запрос или нет?
    - Следует передать запрос следующему обработчику или нет?
4. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже готовые
   цепочки извне. В последнем случае, цепочки собирают фабричные объекты исходя из конфигурации приложения или текущего
   окружения.
5. Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по цепочке
   пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.
6. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:
    - Цепочка может состоять из единственного объекта.
    - Запросы могут не достигать конца цепи.
    - Запросы могут достигать конца, оставаясь необработанными.

### Примеры

#### Пример из стандратной библиотеки Java

- **Пул объектов** ```Logger``` в пакете ```java.util.logging``` использует паттерн Цепочка Обязанностей для обработки
  логов через различные обработчики (```Handler```).

**Как это работает:**

- **Logger:** Представляет собой источник логов.
- **Handler:** Определяет способ обработки логов (например, вывод в консоль, запись в файл).
- **Filter:** Может использоваться для фильтрации логов перед обработкой.

```java
import java.util.logging.*;

public class LoggerChainExample {
    public static void main(String[] args) {
        Logger logger = Logger.getLogger("MyLogger");
        logger.setUseParentHandlers(false); // Отключаем стандартные обработчики

        // Создаем и добавляем консольный обработчик
        ConsoleHandler consoleHandler = new ConsoleHandler();
        consoleHandler.setLevel(Level.INFO);
        logger.addHandler(consoleHandler);

        // Создаем и добавляем файловый обработчик
        try {
            FileHandler fileHandler = new FileHandler("app.log");
            fileHandler.setLevel(Level.FINE);
            logger.addHandler(fileHandler);
        } catch (Exception e) {
            e.printStackTrace();
        }

        // Логируем сообщения разного уровня
        logger.severe("Severe message");
        logger.warning("Warning message");
        logger.info("Info message");
        logger.fine("Fine message"); // Запишется только в файл
    }
}
```

#### [Пример](code%2Fexample2_web%2FMain.java): Обработка Запросов в Веб-Сервере

Создадим цепочку обработчиков, которые поочередно обрабатывают запросы, пока один из них не сможет их обработать.

---

Общий интерфейс обработчиков ```Handler```

```java
public interface Handler {
    void setNextHandler(Handler handler);

    void handleRequest(String request);
}
```

---

Асбтрактный класс обработчика ```AbstarctHandler```

Зачастую бывает оптимальнее создать асбтракный класс реализующий интерфейс и наследоваться от него. Либо работать сразу
с абстрактным классом без интефрейсов. Абстрактный класс позволяет вынести логику связывания обработчиков в одно место.

```java
public abstract class AbstarctHandler implements Handler {
    protected Handler nextHandler;

    @Override
    public void setNextHandler(Handler handler) {
        this.nextHandler = handler;
    }
}
```

---

```AuthenticationHandler``` обрабатывает запрос "```authenticate```" и передает следующий запрос "```authorize```" в
цепочке.

```java
public class AuthenticationHandler extends AbstarctHandler {

    @Override
    public void handleRequest(String request) {
        if (request.equalsIgnoreCase("authenticate")) {
            System.out.println("AuthenticationHandler: Authenticated the request.");
            if (Objects.nonNull(nextHandler)) nextHandler.handleRequest("authorize");
        } else {
            System.out.println("AuthenticationHandler: Cannot handle the request. Passing to next handler.");
            if (Objects.nonNull(nextHandler)) nextHandler.handleRequest(request);
        }
    }
}
```

---

```AuthorizationHandler``` обрабатывает запрос "```authorize```" и передает следующий запрос "```log```".

```java
public class AuthorizationHandler extends AbstarctHandler {
    @Override
    public void handleRequest(String request) {
        if (request.equalsIgnoreCase("authorize")) {
            System.out.println("AuthorizationHandler: Authorized the request.");
            if (Objects.nonNull(nextHandler)) nextHandler.handleRequest("log");
        } else {
            System.out.println("AuthorizationHandler: Cannot handle the request. Passing to next handler.");
            if (Objects.nonNull(nextHandler)) nextHandler.handleRequest(request);
        }
    }
}
```

---

```LoggingHandler``` обрабатывает запрос "```log```".

```java
public class LoggingHandler extends AbstarctHandler {
    public void handleRequest(String request) {
        if (request.equalsIgnoreCase("log")) System.out.println("LoggingHandler: Logged the request.");
        else System.out.println("LoggingHandler: Cannot handle the request.");
    }
}
```

---

При отправке неизвестного запроса "```unknown```" все обработчики пытаются его обработать, но ни один из них не
справляется.

```java
public class Main {
    public static void main(String[] args) {
        // Создание обработчиков
        Handler authHandler = new AuthenticationHandler();
        Handler authorizationHandler = new AuthorizationHandler();
        Handler loggingHandler = new LoggingHandler();

        // Настройка цепочки
        authHandler.setNextHandler(authorizationHandler);
        authorizationHandler.setNextHandler(loggingHandler);

        // Отправка запроса в цепочку
        System.out.println("Client: Sending 'authenticate' request.");
        authHandler.handleRequest("authenticate");

        System.out.println("\nClient: Sending 'unknown' request.");
        authHandler.handleRequest("unknown");
    }
}
```

### Плюсы данного паттерна

- **Снижение связанности:** Отправитель запроса не знает, какой обработчик его обработает. Это облегчает изменение и
  расширение системы.
- **Гибкость цепочки обработчиков:** Можно динамически добавлять, удалять или изменять обработчики в цепочке без
  изменения кода отправителя.
- **Повторное использование обработчиков:** Один и тот же обработчик может использоваться в разных цепочках.
- **Упрощение добавления новых обработчиков:** Новые обработчики могут быть добавлены без изменения существующих
  классов.

### Недостатки данного паттерна

- **Неопределенность обработки:** Запрос может остаться необработанным, если ни один из обработчиков не справится с ним.
- **Отладка:** Может быть сложно отследить, какой обработчик в цепочке обработал запрос.
- **Избыточность:** Создание множества обработчиков может привести к увеличению количества классов и усложнению
  структуры системы.

### Заключение

Паттерн **Цепочка Обязанностей (Chain of Responsibility)** является мощным инструментом для управления запросами и
распределения ответственности между объектами без жесткой связки между ними. Он обеспечивает гибкость и расширяемость
системы, позволяя легко добавлять новые обработчики и изменять существующие.

Однако, при использовании паттерна необходимо учитывать возможные недостатки, такие как неопределенность обработки
запросов и сложность отладки.

### Источники

- Design Patterns with Java: Chain of Responsibility
- Введение в паттерны проектирования: Цепочка обязаностей
- [Habr: Шаблон проектирования: Chain of Responsibility](https://habr.com/ru/articles/727454/)
- [Baeldung: Chain of Responsibility Design Pattern in Java](https://www.baeldung.com/chain-of-responsibility-pattern)