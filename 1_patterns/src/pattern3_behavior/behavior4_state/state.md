# State

## Состояние

**Состояние** — это поведенческий паттерн проектирования,который позволяет объектам менять поведение взависимости от
своего состояния. Извне создаётся впечатление, что изменился класс объекта.

Паттерн схож с конечным автоматом и предназначен для избавление от множества if и switch операторов.
Проблема if и switch операторов заключается в их негибоксти и нагромажденности. Зачастую множество if операторов лежит в
одном месте, что ещё больше усложняет понимает контекста. При паттерне **Состояние** особенности поведение переносят в
класс состояния, тем самым убирая множественно ветвление.

*Задумайтесь об использовании **Состояния** там, где у вас много if и switch операторов*.

#### Основная идея

Паттерн Состояние разделяет функциональность объекта на отдельные классы, каждый из которых представляет определенное
состояние. Контекст (объект, поведение которого изменяется) содержит ссылку на текущий объект-состояние и делегирует ему
выполнение соответствующих действий.

#### Применение

Паттерн Состояние рекомендуется использовать в следующих случаях:

- **Объект должен изменять свое поведение в зависимости от своего состояния:** Когда поведение объекта должно изменяться
  динамически при изменении его внутреннего состояния.
- **Сложные условные операторы:** Когда в классе много условных операторов (```if```, ```switch```), которые изменяют
  поведение в зависимости от состояния. Паттерн Состояние помогает избежать этого, разделяя поведение на отдельные
  классы.
- **Необходимо легко добавлять новые состояния:** Паттерн облегчает добавление новых состояний без изменения
  существующего кода контекста или других состояний.

### Реализация

1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже
   есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
2. Создайте интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте.
   Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
3. Для каждого фактического состояния, создайте класс, реализующий интерфейс состояния. Переместите весь код, связанный
   с конкретным состоянием в нужный класс. В конце концов, все методы интерфейса состояния должны быть реализованы.
4. Создайте в контексте поле для хранения объектовсостояний, а также публичный метод для изменения значения этого поля.
5. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов
   объекта-состояния.
6. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо
   внутри классов конкретных состояний.

### Примеры

#### Примеры из стандартной Java библиотеки

- **Класс** ```Thread.State``` в пакете ```java.lang``` представляет собой перечисление состояний потока, таких как NEW,
  RUNNABLE, BLOCKED, WAITING, TIMED_WAITING и TERMINATED. Хотя это перечисление, концепция управления поведением потока
  в зависимости от его состояния напоминает паттерн Состояние
- Класс ```JButton``` в пакете ```javax.swing``` управляет своим визуальным состоянием (например, нормальное, нажатое,
  отключенное) и поведением в зависимости от этого состояния. Хотя это не строго паттерн Состояние, концепция изменения
  поведения и внешнего вида компонента в зависимости от состояния соответствует идее паттерна.

#### [Пример](code%2Fexample2_game%2FMain.java) игровой системы с сохранением состояния

Создадим игровую систему, в которой персонаж может находиться в различных
состояниях (```Standing```, ```Running```, ```Jumping```) и реагировать на
команды (```pressRun()```, ```pressJump()```, ```pressStop()```).

---

Интерфейс ```State``` Определяет методы ```pressRun()```, ```pressJump()```, ```pressStop()```, которые могут вызываться
на объекте-состоянии.

```java
public interface State {
    void pressRun(Player player);

    void pressJump(Player player);

    void pressStop(Player player);
}
```

---

```StandingState``` - конкретное состояния - персонаж стоит. Из данного состояния персонаж может начать бежать или
прыгать. Но остановится не может.

```java
public class StandingState implements State {
    @Override
    public void pressRun(Player player) {
        System.out.println("Player starts running.");
        player.setState(new RunningState());
    }

    @Override
    public void pressJump(Player player) {
        System.out.println("Player jumps.");
        player.setState(new JumpingState());
    }

    @Override
    public void pressStop(Player player) {
        System.out.println("Player is already standing.");
    }
}
```

---

```RunningState``` - конкретное состояние - персонаж бежит. Персонаж не может начать бежать так как уже это делает.
Может остановиться или прыгнуть.

```java
public class RunningState implements State {
    @Override
    public void pressRun(Player player) {
        System.out.println("Player is already running.");
    }

    @Override
    public void pressJump(Player player) {
        System.out.println("Player jumps while running.");
        player.setState(new JumpingState());
    }

    @Override
    public void pressStop(Player player) {
        System.out.println("Player stops running.");
        player.setState(new StandingState());
    }
}
```

---

```JumpingState ``` - конкретное состояние - персонаж прыгает. Персонаж не может начать прыгать так как уже это делает.
Может остановиться, но не может бежать пока прыгает.

```java
public class JumpingState implements State {
    @Override
    public void pressRun(Player player) {
        System.out.println("Player cannot run while jumping.");
    }

    @Override
    public void pressJump(Player player) {
        System.out.println("Player is already jumping.");
    }

    @Override
    public void pressStop(Player player) {
        System.out.println("Player lands and stands.");
        player.setState(new StandingState());
    }
}
```

---

```Player``` - класс персонажа, который будет менять состояния.

```java
public class Player {
    private State currentState;

    public Player() {
        // Начальное состояние — стоя
        currentState = new StandingState();
    }

    public void setState(State state) {
        this.currentState = state;
    }

    // Делегирование действий текущему состоянию
    public void pressRun() {
        currentState.pressRun(this);
    }

    public void pressJump() {
        currentState.pressJump(this);
    }

    public void pressStop() {
        currentState.pressStop(this);
    }

    public String getStateName() {
        return currentState.getClass().getSimpleName();
    }
}
```

---

```java
public class Main {
    public static void main(String[] args) {
        Player player = new Player();
        System.out.println("Initial State: " + player.getStateName());

        player.pressRun();
        System.out.println("Current State: " + player.getStateName());

        player.pressJump();
        System.out.println("Current State: " + player.getStateName());

        player.pressRun(); // Попытка бегать во время прыжка
        System.out.println("Current State: " + player.getStateName());

        player.pressStop();
        System.out.println("Current State: " + player.getStateName());

        player.pressStop(); // Попытка остановиться, когда уже стоишь
    }
}
```

### Плюсы данного паттерна

- **Упрощение кода:** Позволяет избавиться от сложных условных операторов (```if```, ```switch```) и заменяет их
  полиморфизмом.
- **Гибкость:** Легко добавлять новые состояния без изменения существующего кода контекста или других состояний.
- **Снижение связанности:** Контекст не знает деталей реализации состояний, что облегчает поддержку и расширение
  системы.
- **Легкость изменения состояний во время выполнения:** Состояние объекта может изменяться динамически в зависимости от
  событий или условий.

### Недостатки данного паттерна

- **Увеличение числа классов:** Каждый новый тип состояния требует создания отдельного класса, что может привести к
  большому количеству классов.
- **Сложность отладки:** Из-за разделения логики на разные классы может быть сложнее отследить поток выполнения
  программы.
- **Необходимость управления состояниями:** Нужно обеспечить правильное управление переходами между состояниями, что
  может усложнить дизайн системы.

### Заключение

Паттерн Состояние (State) предоставляет мощный способ управления поведением объектов в зависимости от их внутреннего
состояния. Он улучшает гибкость и расширяемость системы, позволяя легко добавлять новые состояния и изменять поведение
без изменения основного кода контекста.

При использовании паттерна Состояние важно тщательно проектировать интерфейсы и классы состояний, чтобы обеспечить
максимальную гибкость и минимальную связанность между компонентами системы.

### Источники

- Design Patterns with Java: State
- Введение в паттерны проектирования: Наблюдатель