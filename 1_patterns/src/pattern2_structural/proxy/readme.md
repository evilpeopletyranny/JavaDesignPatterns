<h1 align="center">
   Proxy
</h1>
<h3 align="center">
   Заместитель
</h3>

**Заместитель** — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов
специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или
после передачи вызова оригиналу.

<h3 align="center">
   Применимость:
</h3>

1. "Виртуальный прокси" - ленивая инициализация. Позволяет отложить создание тяжелого объекта до
   необходимости/обращения. Загрузка больших объектов на старте программы может суещсвтенно повлиять на запуск по
   времени и памяти.
2. "Защищающий прокси" - разраничение доступа к объекту/части системы. Через прокси реализуются методы проверки.
3. "Умный прокси/умная ссылка" - когда необходимо кэшировать результаты запросов клиентов и управлять их жизненным
   циклом.
4. "Удаленный прокси" - прокси транслирует запросы клиента в виде понятном удаленными сервису.
5. "Логирующий прокси" - хранит историю обращений к сервисному объекту.
6. "Сихнронизирующий прокси" - проверка доступа к разделяемому ресурсу
7. и тд. Примеров ещё не мало.

<h3 align="center">
   Реализация
</h3>

1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся
   самим заместителем. В редких случаях, заместитель получает готовый сервисный объект от клиента через конструктор.
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какуюто полезную
   работу, методы заместителя должны передать запрос сервисному объекту.
4. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам
   заместителя.

<h3>Плюсы</h3>

- Позволяет контролировать сервисный объект незаметно для клиента.
- Может работать, даже если сервисный объект ещё не создан.
- Может контролировать жизненный цикл служебного объекта.

<h3>Минусы</h3>

- Усложняет программу за счёт дополнительных классов.
- Увеличивает время отклика от сервиса.

<h3 align="center">
   Примеры
</h3>

- [Аспектно-ориентированное программирование (AOP)](https://docs.spring.io/spring-framework/reference/core/aop.html). С
  ним вы познакомитесь на второй ЛР при работе со Spring.
- [Пример с кэширующим прокси youtube сервиса.](code)
- Unmodifiable коллекции. В Java есть прокси для коллекций, который позволяют работать с ними как с иммутабельными.
- Механизм Java Reflection, который позволяет "читать и взамодействовать" с кодом программы на лету также является
  Proxy. Кстати в Spring многое реализовано через механизмы Reflection.

<h3 align="center">
   Proxy UML-диаграмма
</h3>

![diagram.png](diagram.png)

<h3 align="center">
   Сравнение с другими паттернами.
</h3>

- **Фасад**. Прокси похож на фасад, тем что замещает сложный объект и может управлять его иниализацией и жизненмы
  циклом. **НО** прокси имеет тот же интерфейс и взаимозаменяем со служебным объектом. Также в освном фасад транслирует
  данные и операции без дополнительного влияния на них, в то время как прокси создается ради влияния на данные и
  функционал.
- **Декоратор**. И прокси и декоратор построены на композиции и делегируют работу объектам. **Прокси** сам управляет
  жизнью сервисного объекта, а обертование **Декораторов** контролируется клиентом.

<h3 align="center">
   Источники
</h3>

- Design Patterns with
  Java: [Proxy](books/Olaf%20Musch%20EN.pdf)
- Введение в паттерны
  проектирования: [Заместитель](books/Alexander%20Shvets%20RU.pdf)