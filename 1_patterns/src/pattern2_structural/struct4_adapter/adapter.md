# Adapter

## Адаптер

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать
вместе.

В разработке программного обеспечения часто возникает необходимость интегрировать различные компоненты и системы,
которые изначально не предназначены для совместной работы. Паттерн проектирования **Адаптер** (Adapter) предоставляет
способ сделать это, преобразуя интерфейс одного класса в интерфейс, ожидаемый клиентом. Это позволяет классам с
несовместимыми интерфейсами работать вместе без изменения их исходного кода.

#### Основная идея

Основная идея паттерна Адаптер заключается в том, чтобы предоставить промежуточный слой между двумя несовместимыми
интерфейсами, позволяющий им взаимодействовать без изменения их исходного кода.

#### Применение

Паттерн Адаптер рекомендуется использовать в следующих случаях:

- Необходимо использовать существующий класс, но его интерфейс несовместим с текущей системой.
- Разработка новых классов, совместимых с существующей системой.
- Интеграция библиотек или систем, имеющих разные интерфейсы.
- Превращение интерфейса одного класса в другой, ожидаемый клиентом.

### Реализация

1. Убедитесь, что у вас есть два класса с неудобными интерфейсами:
    - *полезный сервис* — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой
      код);
    - *один или несколько клиентов* — классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего
      интерфейса.
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать сторонний класс.
3. Создайте класс адаптера, реализовав этот интерфейс.
4. Поместите в адаптер поле-ссылку на объект-сервис. В большинстве случаев, это поле заполняется объектом, переданным в
   конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису
6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять
   адаптеры в будущем.

#### Вариации

Адаптер можно реализовать двумя способами:

- Основанном на классах. При этом используется наследование.
- Основанном на объектах. При этом используется композиция.

Оба подхода описаны в предлагаемых книгах.

В данном случае мы будем рассматривать подход основанный на композиции. Данный подход предпочтительней, так как:

- Наследование создает жесткую связь с классом родителя.
- Изменение класса родителя может влиять на адаптер.
- Класс не всегда можно унаследовать.
- Композиция позволяет добиться большей гибкости.

### Примеры

#### Примеры паттерна адаптер в стандартной библиотеке Java

- Метод ```Arrays.asList()``` адаптирует массив к интерфейсу ```List```. Возвращаемый объект реализует интерфейс List,
  позволяя работать с массивом как с коллекцией.
- Классы ```InputStreamReader``` и ```OutputStreamWriter``` адаптируют байтовые потоки (```InputStream```
  и ```OutputStream```) к символьным потокам (```Reader``` и ```Writer```), позволяя работать с байтовыми данными как с
  символами.
- Класс ```Scanner``` адаптирует поток ввода (```InputStream```, ```Readable```) к удобному интерфейсу для чтения данных
  различных типов.

#### [Пример](code%2Fexample1_sort%2FSorterExternalProduct.java) с интерфейсами сортировки массива и списка

Представим ситауцию, что нам необходимо отсортировать массив целых чисел, но реализация мега быстрого и оптимального
алгоритма сортировки целых чисел у нас есть только для списка. Реализуем адаптер, который будет при помощи супер
алгоритма сортировки списка сортировать масссив.

```java
/**
 * Интерфейс, которому мы должны следовать.
 */
public interface Sorter {
    /**
     * Сортировка массива чисел
     */
    int[] sort(int... numbers);
}
```

```java
/**
 * Внешний API от которого мы не можем налседоваться и не можем
 * менять его реализацию.
 */
public final class SorterExternalProduct {
    /**
     * Сортировка Листа
     */
    List<Integer> sort(List<Integer> numberList) {
        List<Integer> resList = new ArrayList<>(numberList.size());
        resList.addAll(numberList);
        Collections.sort(resList);
        return resList;
    }
}
```

```java
/**
 * Реализация адаптера.
 * Реализовывая необходимый интерфейс (Sorter) мы используем внешний
 * API (SorterExternalProduct).
 */
public class SorterAdapter implements Sorter {
    private final SorterExternalProduct externalProduct = new SorterExternalProduct();

    /**
     * Реализуем необходимый функционал, используя внешний API.
     * <p>
     * Суть адаптера в данном случае том, что мы адаптировали внешний API в виде
     * функции сортировки Листа к текущему интерфейсу.
     */
    @Override
    public int[] sort(int... numbers) {
        List<Integer> numberList = new ArrayList<>();
        for (var number : numbers) numberList.add(number);
        var sortedList = externalProduct.sort(numberList);
        for (var i = 0; i < sortedList.size(); i++) numbers[i] = sortedList.get(i);
        return numbers;
    }
}
```

#### [Пример](code%2Fexample3_logger%2FApplication.java) с интерфейсами логгирования

Предположим, у нас есть существующая система, которая использует интерфейс ```Logger``` для записи логов. Мы хотим
подключить новую систему логирования, имеющую другой интерфейс ```NewLogger```. Вместо изменения существующего кода, мы
реализуем адаптер, который позволит использовать новую систему с интерфейсом ```Logger```.

Интерфейс в нашей программе:

```java
public interface Logger {
    void logInfo(String message);

    void logError(String message);
}
```

Новый логгер который мы хотим использовать.

```java
public class NewLogger {
    public void log(String severity, String message) {
        System.out.println("[" + severity + "] " + message);
    }
}
```

Класс адаптер

```java
// LoggerAdapter.java
public class LoggerAdapter implements Logger {
    private NewLogger newLogger;

    public LoggerAdapter(NewLogger newLogger) {
        this.newLogger = newLogger;
    }

    @Override
    public void logInfo(String message) {
        newLogger.log("INFO", message);
    }

    @Override
    public void logError(String message) {
        newLogger.log("ERROR", message);
    }
}
```

```java
// Application.java
public class Application {
    private Logger logger;

    public Application(Logger logger) {
        this.logger = logger;
    }

    public void doWork() {
        logger.logInfo("Application is starting.");
        try {
            // Симуляция работы
            System.out.println("Application is working...");
            throw new RuntimeException("Something went wrong!");
        } catch (Exception e) {
            logger.logError(e.getMessage());
        } finally {
            logger.logInfo("Application is shutting down.");
        }
    }

    public static void main(String[] args) {
        // Подключение новой системы логирования через адаптер
        NewLogger newLogger = new NewLogger();
        Logger loggerAdapter = new LoggerAdapter(newLogger);

        Application app = new Application(loggerAdapter);
        app.doWork();
    }
}
```

### Плюсы данного паттерна

- **Повторное использование кода:** Позволяет использовать существующие классы с несовместимыми интерфейсами без
  изменения их кода.
- **Снижение связанности:** Клиентский код зависит только от интерфейса, а не от конкретных адаптируемых классов.
- **Гибкость:** Можно легко адаптировать новые системы или библиотеки без необходимости переписывать существующий код.
- **Упрощение интеграции:** Облегчает интеграцию сторонних библиотек или компонентов в проект.

### Недостатки данного паттерна

- **Усложнение структуры:** Добавляет дополнительный слой абстракции, что может увеличить сложность системы.
- **Избыточность:** В некоторых случаях может быть избыточным, особенно если интерфейсы могут быть изменены.
- **Надежность:** Требует тщательной реализации адаптера, чтобы избежать ошибок преобразования данных.

### Заключение

Паттерн проектирования Адаптер является мощным инструментом для интеграции различных компонентов и систем с
несовместимыми интерфейсами. Он позволяет сохранять существующий код неизменным, обеспечивая при этом гибкость и
расширяемость приложения. В стандартной Java библиотеке паттерн Адаптер широко используется для адаптации различных
интерфейсов и классов, обеспечивая удобство и типовую безопасность при работе с коллекциями, потоками ввода-вывода и
другими компонентами.

При правильном применении паттерн Адаптер способствует созданию более модульного, гибкого и поддерживаемого кода,
облегчая интеграцию новых технологий и систем без необходимости радикальных изменений в существующей архитектуре.

### Источники

- Design Patterns with Java: Adapter
- Введение в паттерны проектирования: Адаптер
- [Habr: Java Adapter Pattern in Game Server](https://habr.com/ru/articles/577220/)
- [JavaRush: Паттерн проектирования Адаптер](https://javarush.com/groups/posts/2139-pattern-proektirovanija-adapter)
- [Шаблон адаптера в Java](https://for-each.dev/lessons/b/-java-adapter-pattern) пример использования Адаптера для
  конвертации данных.