# Bridge

## Мост

**Мост** — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные
иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

В разработке программного обеспечения часто возникает необходимость создавать системы, которые могут изменяться
независимо от других компонентов. Паттерн проектирования **Мост** (Bridge) является одним из структурных паттернов,
который
помогает разделить абстракцию и её реализацию, позволяя изменять их независимо друг от друга. Это особенно полезно в
сложных системах, где требуется гибкость и расширяемость.

**Паттерн Мост** — это **структурный** паттерн проектирования, который разделяет абстракцию и реализацию таким образом,
чтобы они могли изменяться независимо друг от друга. Он достигается путем создания двух иерархий классов:

1. **Абстракция (Abstraction):** Определяет высокоуровневую часть интерфейса и содержит ссылку на объект реализации.
2. **Реализация (Implementor):** Определяет низкоуровневую часть интерфейса, которая выполняет конкретные действия.

Паттерн Мост позволяет изменять абстракции и реализации независимо, что способствует повышению гибкости и уменьшению
связанности компонентов системы.

#### Основная идея

Основная идея паттерна Мост заключается в разделении функциональности на две независимые части: абстракцию и реализацию.
Это позволяет изменять или расширять одну часть без влияния на другую.

#### Применение

Паттерн Мост рекомендуется использовать в следующих случаях:

- **Необходимо разделить абстракцию и реализацию:** Когда изменения в одной из частей не должны влиять на другую.
- **У вас есть несколько вариаций абстракций и реализаций:** Когда необходимо сочетать различные абстракции с различными
  реализациями.
- **Хотите увеличить гибкость системы:** Паттерн Мост обеспечивает возможность динамического изменения реализации во
  время выполнения.

### Реализация

1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа,
   предметная-область/ инфраструктура, фронт-энд/бэк-энд или интерфейс/ реализация.
2. Продумайте, какие операции будут нужны клиентам и опишите их в базовом классе абстракции.
3. Определите поведения доступные на всех платформах и выделите из них ту часть, которая будет нужная абстракции. На
   основании этого опишите общий интерфейс реализации
4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который
   мы выделили перед этим.
5. Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную работу
   связанному объекту реализации.
6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может
   свободно использовать объект абстракции, забыв о реализации.

### Примеры

#### [Пример](code%2Fexample1_shapes%2FMain.java): Создание системы фигур различного окраса

Предположим нам надо создать набор фигур (```Rectangle```, ```Triangle```) с разными
цветвами (```RedColor```, ```GreenColor```, ```BlackColor```). Паттерн Мост позволит нам разделить абстракцию фигуры и
реализацию цвета, обеспечивая гибкость и расширяемость.

```java
/**
 * Класс Shape представляет собой Абстракцию — механизм управления раскраской фигур в различные цвета, который
 * делегирует Реализацию интерфейсу Color.
 * "Абстракция"
 * <p>
 * Отдается предпочтение абстрактному классу вместо интерфейса из-за возможности
 * указания полей.
 */
public abstract class Shape {
    protected Color color;      //реализация цвета

    public Shape(Color color) {
        this.color = color;
    }

    public abstract void draw();
}
```

```java
/**
 * Интерфейс реализации цвета.
 * "Реализация"
 */
public interface Color {
    void fillColor();
}
```

```java
/**
 * Конкретная реализация.
 * Черный цвет
 */
public class BlackColor implements Color {
    @Override
    public void fillColor() {
        System.out.println("Filling in black color");
    }
}
```

```java
/**
 * Конкретная реализация.
 * Зеленый цвет
 */
public class GreenColor implements Color {
    @Override
    public void fillColor() {
        System.out.println("Filling in green color");
    }
}
```

```java
/**
 * Конкретная реализация.
 * Красный цвет
 */
public class RedColor implements Color {
    @Override
    public void fillColor() {
        System.out.println("Filling in red color");
    }
}
```

```java
/**
 * Уточненная абстракция - прямоугольник
 */
public class Rectangle extends Shape {

    public Rectangle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("Drawing rectangle");
        color.fillColor();
    }
}
```

```java
/**
 * Уточненная абстракция - треугольник
 */
public class Triangle extends Shape {

    public Triangle(Color color) {
        super(color);
    }

    @Override
    public void draw() {
        System.out.println("Drawing rectangle");
        color.fillColor();
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Shape rect = new Rectangle(new RedColor());
        rect.draw();

        System.out.println("---------------");

        Shape triangle = new Triangle(new GreenColor());
        triangle.draw();
    }
}
```

#### JDBC

JDBC - механизм работы с БД средствами Java. Разделяется абстракцию - сам интерфейс JDBC и реализации - драйверы разных
СУБД. В зависимости от ситуации под интерфейс JDBC прячется необходимый драйвер при этом для пользователя ничего не
меняется - интерфейс JDBC остается прежним.

### Плюсы данного паттерна

- **Разделение абстракции и реализации:** Позволяет изменять и расширять абстракцию и реализацию независимо друг от
  друга.
- **Гибкость:** Облегчает добавление новых абстракций и реализаций без изменения существующего кода.
- **Снижение связанности:** Уменьшает зависимость между высокоуровневыми и низкоуровневыми частями системы.
- **Повторное использование кода:** Позволяет использовать одни и те же реализации с разными абстракциями и наоборот.

### Недостатки данного паттерна

- **Сложность:** Увеличивает количество классов и интерфейсов, что может усложнить понимание системы.
- **Увеличение количества кода:** Требуется дополнительный код для создания абстракций и реализаций.
- **Непрямой доступ:** Клиент может не иметь прямого доступа к методам реализации, что иногда ограничивает возможности.

### Заключение

Паттерн проектирования **Мост** является мощным инструментом для создания гибких и расширяемых систем, позволяя
разделять абстракцию и реализацию. В стандартной библиотеке Java паттерн Мост реализован в таких компонентах, как Swing
и JDBC, обеспечивая их гибкость и модульность.

Понимание и правильное применение паттерна Мост способствует созданию более поддерживаемого и масштабируемого кода, что
особенно важно в больших и сложных проектах. Однако, как и любой паттерн, он должен применяться там, где это
действительно необходимо, чтобы избежать избыточной сложности системы.

### Источники

- Design Patterns with Java: Bridge
- Введение в паттерны проектирования: Мост