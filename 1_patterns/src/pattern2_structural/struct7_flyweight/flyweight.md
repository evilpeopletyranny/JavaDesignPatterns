# Flyweight

## Легковес

**Легковес** — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в
отведённую оперативной память за счёт экономного разделения общего состояния объектов между собой, вместо хранения
одинаковых данных в каждом объекте.

В разработке программного обеспечения часто сталкиваются с задачами управления большим количеством объектов, которые
могут иметь схожие характеристики. Это приводит к увеличению потребления памяти и снижению производительности системы.
Структурный паттерн проектирования **Легковес** (Flyweight) предоставляет решение этой проблемы, позволяя эффективно
использовать память за счёт разделения общих (внутренних) и уникальных (внешних) данных объектов.

#### Основная идея

Основная идея паттерна Легковес заключается в разделении состояния объекта на внутреннее (shared) и внешнее (unshared).
Внутреннее состояние хранится в одном экземпляре и разделяется между всеми объектами, а внешнее состояние передаётся
клиенту и хранится отдельно.

#### Применение

Паттерн Легковес рекомендуется использовать в следующих случаях:

- Необходимо создать большое количество мелких объектов, расходующих много памяти.
- Объекты могут иметь общие части состояния, которые могут быть разделены между ними.
- Хотите уменьшить количество создаваемых объектов для повышения производительности.
- Требуется обеспечить разделение внутреннего и внешнего состояния объектов.

### Реализация

1. Разделите поля класса, который станет легковесом, на две части:
    - внутреннее состояние: значения этих полей одинаковы для большого числа объектов
    - внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояние в классе, но убедитесь, что их значения неизменяемы. Эти поля должны
   инициализироваться только через конструктор.
3. Превратите поля внешнего состояния в аргументы методов, где эти поля использовались. Затем, удалите поля из класса
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен запрашивать
   легковеса с определённым внутренним состоянием из этой фабрики, а не создавать его напрямую
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта
   легковеса.

### Примеры

#### Примеры паттерна адаптер в стандартной библиотеке Java

- **String Pool (Пул строк)** в Java является примером применения паттерна Легковес. В Java существует пул строк,
  который хранит все строковые литералы и обеспечивает их повторное использование. Это снижает потребление памяти,
  особенно при работе с большим количеством одинаковых строк.
- **Кэширование объектов** Integer — ещё один пример паттерна Легковес. В Java для значений Integer от -128 до 127
  объекты кэшируются, что позволяет повторно использовать существующие экземпляры, снижая потребление памяти.
- **Класс** Color в пакете ```java.awt``` использует паттерн Легковес для хранения стандартных цветов. Объекты
  стандартных цветов, таких как Color.RED, Color.BLUE, повторно используются, что экономит память.

#### [Пример](code%2Fexample2_characters%2FFlyweightPatternMain.java) паттерна легковес при рахзработке текстового редактора

```java
public interface CharacterFlyweight {
    void display(CharacterContext context);
}
```

```ConcreteCharacterFlyweight``` хранит внутреннее состояние: символ, шрифт и размер.

```java
public class ConcreteCharacterFlyweight implements CharacterFlyweight {
    private final char character;
    private final String font;
    private final int size;

    public ConcreteCharacterFlyweight(char character, String font, int size) {
        this.character = character;
        this.font = font;
        this.size = size;
    }

    @Override
    public void display(CharacterContext context) {
        System.out.println("Character: " + character + ", Font: " + font + ", Size: " + size +
                ", Position: (" + context.getX() + ", " + context.getY() + ")");
    }
}
```

```CharacterFlyweightFactory``` управляет созданием и хранением экземпляров ```ConcreteCharacterFlyweight```. Если необходимый экземпляр уже существует, он возвращается из кэша.

```java
import java.util.HashMap;
import java.util.Map;

public class CharacterFlyweightFactory {
    private static final Map<String, CharacterFlyweight> flyweights = new HashMap<>();

    public static CharacterFlyweight getCharacter(char character, String font, int size) {
        String key = character + "-" + font + "-" + size;
        if (!flyweights.containsKey(key)) {
            flyweights.put(key, new ConcreteCharacterFlyweight(character, font, size));
            System.out.println("Creating new Flyweight for: " + key);
        }
        return flyweights.get(key);
    }

    public static int getFlyweightCount() {
        return flyweights.size();
    }
}
```

```CharacterContext``` содержит внешнее состояние: позицию символа в тексте.

```java
public class CharacterContext {
    private final int x;
    private final int y;

    public CharacterContext(int x, int y) {
        this.x = x;
        this.y = y;
    }

    // Геттеры для внешнего состояния
    public int getX() {
        return x;
    }

    public int getY() {
        return y;
    }
}
```

```java
public class FlyweightPatternMain {
    public static void main(String[] args) {
        String text = "HELLO HELLO";
        String font = "Arial";
        int size = 12;

        int x = 0;
        int y = 0;

        for (char c : text.toCharArray()) {
            CharacterFlyweight flyweight = CharacterFlyweightFactory.getCharacter(c, font, size);
            CharacterContext context = new CharacterContext(x, y);
            flyweight.display(context);
            x += 10; // Увеличение позиции по оси X
        }

        System.out.println("Total Flyweight objects created: " + CharacterFlyweightFactory.getFlyweightCount());
    }
}
```

### Плюсы данного паттерна

- **Экономия памяти:** Позволяет уменьшить количество создаваемых объектов за счёт повторного использования существующих
  экземпляров.
- **Повышение производительности:** Снижение нагрузки на систему благодаря уменьшению объёмов памяти и ускорению доступа
  к кэшированным объектам.
- **Гибкость:** Легко добавлять новые типы объектов без изменения существующего кода.
- **Упрощение управления объектами:** Централизованное управление экземплярами через фабрику или кэш.

### Недостатки данного паттерна

- **Сложность реализации**: Требует дополнительного кода для управления кэшем и разделения состояния.
- **Сложность управления состоянием:** Необходимо чётко разделять внутреннее и внешнее состояние, чтобы избежать ошибок
  при повторном использовании объектов.
- **Потенциальные проблемы с синхронизацией:** В многопоточных приложениях необходимо обеспечить корректное управление
  доступом к кэшу.

### Заключение

Паттерн проектирования Легковес является эффективным инструментом для оптимизации использования памяти и повышения
производительности приложений, особенно при работе с большим количеством схожих объектов.

Однако, как и любой паттерн, Легковес должен применяться осознанно, учитывая требования и специфику проекта.
Неправильное разделение состояния или управление кэшем может привести к ошибкам и ухудшению производительности.

Понимание и правильное применение паттерна Легковес способствует созданию более эффективных и масштабируемых систем,
снижая потребление ресурсов и улучшая общую производительность приложения.

### Источники

- Design Patterns with Java: Flyweight
- Введение в паттерны проектирования: Легковес