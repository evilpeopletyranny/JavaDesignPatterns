# Singleton

## Одиночка>

**Одиночка** — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и
предоставляет к нему глобальную точку доступа.

1. Синглтон гарантирует наличие единственного экземпляра класса.
   Чаще всего это полезно для доступа к какому-то общему
   ресурсу, например, базе данных.
2. Предоставляет глобальную точку доступа. Это не просто
   глобальная переменная, через которую можно достучаться
   к определённому объекту. Глобальные переменные не
   защищены от записи, поэтому любой код может подменять
   их значения без вашего ведома.

#### Основная идея

Основная идея паттерна Синглтон заключается в том, чтобы контролировать создание экземпляра класса, гарантируя, что он
существует в единственном числе, и обеспечивать доступ к нему из любой части программы.

#### Применение

Паттерн Синглтон рекомендуется использовать в следующих случаях:

- **Необходимость наличия одного и только одного экземпляра класса**: Например, класс, управляющий подключением к базе
  данных, логированием, конфигурациями приложения.
- **Предоставление глобальной точки доступа**: Когда необходимо обеспечить доступ к одному экземпляру класса из разных
  частей программы.
- **Контроль над доступом к ресурсам**: Например, управление пулом соединений, потоками и т.д.

### Реализация

Все реализации одиночки сводятся к тому, чтобы скрыть
конструктор по умолчанию и создать публичный
статический метод, который и будет контролировать
жизненный цикл объекта-одиночки.

Принято, что статисческое поле, хранящее ссылку на переменную имеет название ```instance```, а статический метод
получения доступа к экземпляру ```getInstance()```.
*Все к этому привыкли, так что используйте только такие названия.*
***Гадать что имел ввиду автор люди не любях и не хотят!***

### Примеры

#### [Eager Initialization Singleton](code%2Fexample1_eager_init%2FEagerSingleton.java) (Жадная инициализация)

В этой реализации экземпляр создаётся при загрузке класса. Это простая реализация, но она не поддерживает ленивую
инициализацию (отложенное создание экземпляра до первого обращения).

```java
public class EagerSingleton {
    // Создание экземпляра при загрузке класса
    private static final EagerSingleton INSTANCE = new EagerSingleton();

    // Приватный конструктор
    private EagerSingleton() {
    }

    // Публичный метод доступа
    public static EagerSingleton getInstance() {
        return INSTANCE;
    }
}
```

##### Плюсы:

- Простота реализации.
- Потокобезопасность без дополнительной синхронизации.

##### Минусы:

- Экземпляр создаётся даже если он никогда не используется.
- Может приводить к неэффективному использованию ресурсов.

#### [LazySingleton](code%2Fexample2_lazy_init%2FLazySingleton.java) (Ленивая инициализация)

Экземпляр создаётся только при первом обращении к нему. Это позволяет избежать создания ненужных объектов.

**_Основная реализация для ЛР 1_**

```java
public class LazySingleton {
    private static LazySingleton instance;

    private LazySingleton() {
    }

    public static LazySingleton getInstance() {
        if (instance == null) {
            instance = new LazySingleton();
        }
        return instance;
    }
}
```

##### Плюсы:

- Экземпляр создаётся только при необходимости.
- Экономия ресурсов, если объект никогда не используется.

##### Минусы:

- Не потокобезопасен. В многопоточной среде может привести к созданию нескольких экземпляров.
- Требуется дополнительная синхронизация для обеспечения потокобезопасности.

#### [ThreadSafeSingleton](code%2Fexample3_tread_safe%2FThreadSafeSingleton.java) (Потокобезопасный синглтон)

Реализация с использованием синхронизированного метода, который обеспечивает потокобезопасность.

```java
public class ThreadSafeSingleton {
    private static ThreadSafeSingleton instance;

    private ThreadSafeSingleton() {
    }

    public static synchronized ThreadSafeSingleton getInstance() {
        if (instance == null) {
            instance = new ThreadSafeSingleton();
        }
        return instance;
    }
}
```

##### Плюсы:

- Потокобезопасен.
- Гарантирует наличие только одного экземпляра.

##### Минусы:

- Синхронизация снижает производительность, так как метод блокируется на каждом вызове.
- Необходимость использования ```synchronized``` на уровне метода.

#### [Double-Checked Locking](code%2Fexample4_double_check%2FDoubleCheckedLockingSingleton.java) (Двойная проверка блокировки)

Эффективная реализация потокобезопасного синглтона, которая уменьшает накладные расходы на синхронизацию.

```java
// DoubleCheckedLockingSingleton.java
public class DoubleCheckedLockingSingleton {
    private static volatile DoubleCheckedLockingSingleton instance;

    private DoubleCheckedLockingSingleton() {
    }

    public static DoubleCheckedLockingSingleton getInstance() {
        if (instance == null) { // Первая проверка (без синхронизации)
            synchronized (DoubleCheckedLockingSingleton.class) {
                if (instance == null) { // Вторая проверка (с синхронизацией)
                    instance = new DoubleCheckedLockingSingleton();
                }
            }
        }
        return instance;
    }
}
```

##### Плюсы:

- Потокобезопасен.
- Синхронизация происходит только при первом создании экземпляра.
- Улучшенная производительность по сравнению с полностью синхронизированным методом.

##### Минусы:

- Более сложная реализация.
- Необходимо использовать ```volatile``` для переменной ```instance```, чтобы предотвратить проблемы с кэшированием в
  многопоточной среде.

#### Bill Pugh Singleton Implementation (Реализация Синглтона Биллом Пагом)

Использует внутренний статический класс для создания экземпляра, что обеспечивает ленивую инициализацию и
потокобезопасность без использования синхронизации.

```java
public class BillPughSingleton {
    private BillPughSingleton() {
    }

    // Внутренний статический класс
    private static class SingletonHelper {
        private static final BillPughSingleton INSTANCE = new BillPughSingleton();
    }

    public static BillPughSingleton getInstance() {
        return SingletonHelper.INSTANCE;
    }
}
```

##### Плюсы:

- Потокобезопасен без использования синхронизации.
- Ленивая инициализация.
- Простота реализации.

##### Минусы:

- Не поддерживается до Java 5 из-за проблем с загрузкой классов.

#### Enum Singleton (Синглтон через Enum)

Использование ```enum``` для реализации Синглтона — самый простой и эффективный способ, который обеспечивает
сериализацию и защиту от рефлексии.

**_Тоже неплохой способ для ЛР 1_**

```java
public enum EnumSingleton {
    INSTANCE;

    // Методы и поля
    public void someMethod() {
        System.out.println("Метод EnumSingleton");
    }
}
```

##### Плюсы:

- Простота реализации.
- Потокобезопасен по умолчанию.
- Защита от создания дополнительных экземпляров через рефлексию и сериализацию.
- Автоматическая поддержка сериализации.

##### Минусы:

- Не подходит, если требуется наследование (так как ```enum``` не может наследоваться).
- Не всегда интуитивно понятно для разработчиков, не знакомых с этим подходом.

### Преимущества и недостатки различных реализаций

| Реализация                 | Потокобезопасность | Ленивая инициализация | Простота реализации | Производительность              | Защита от рефлексии/сериализации |
|----------------------------|--------------------|-----------------------|---------------------|---------------------------------|----------------------------------|
| **Eager Initialization**   | Да                 | Нет                   | Простая             | Высокая                         | Частично                         |
| **Lazy Initialization**    | Нет                | Да                    | Простая             | Высокая (но не потокобезопасна) | Нет                              |
| **Thread-Safe Singleton**  | Да                 | Да                    | Простая             | Низкая (из-за синхронизации)    | Да                               |
| **Double-Checked Locking** | Да                 | Да                    | Средняя             | Высокая                         | Да                               |
| **Bill Pugh Singleton**    | Да                 | Да                    | Простая             | Высокая                         | Частично                         |
| **Enum Singleton**         | Да                 | Да                    | Очень простая       | Высокая                         | Полная                           |

### Почему singleton антипаттерн?

Несмотря на свою популярность, паттерн Синглтон часто критикуется и рассматривается как антипаттерн по ряду причин:

1. **Глобальное состояние**. Синглтон предоставляет глобальную точку доступа к экземпляру, что фактически создает
   глобальное состояние. Глобальные переменные известны своими проблемами, такими как:
    - Скрытые зависимости: Классы, использующие Синглтон, зависят от него неявно, что затрудняет понимание зависимостей
      и ведение кода.
    - Трудности в тестировании: Глобальные состояния усложняют написание юнит-тестов, так как состояние Синглтона может
      влиять на другие тесты.
2. **Усложнение модульности и расширяемости**. Синглтон может затруднить расширение и модификацию системы, поскольку все
   части программы, использующие Синглтон, напрямую зависят от его конкретной реализации.
3. **Нарушение принципа единственной ответственности (Single Responsibility Principle)**. Синглтон отвечает за создание
   объекта, управление доступа к нему. Также сама суть синглтона накладывает ограничения на поведение.
4. **Проблемы с наследованием**. Синглтон затрудняет наследование, так как создание экземпляров контролируется самим
   классом.
5. **Необходимость синхронизации**. Некоторые реализации Синглтона требуют синхронизации, что может негативно сказаться
   на производительности и привести к ошибкам в многопоточной среде.
6. **Уязвимость к рефлексии и сериализации**. Некоторые реализации Синглтона могут быть нарушены с помощью рефлексии или
   сериализации, что позволяет создавать дополнительные экземпляры.
7. **Проблемы с управлением жизненным циклом**. Синглтон живёт на протяжении всей жизни приложения, что может привести к
   утечкам памяти, если он хранит ссылки на объекты, которые уже не нужны.
8. **Нарушение принципов SOLID**
    - **Принцип открытости/закрытости (Open/Closed Principle)**: Синглтон может требовать изменения кода при добавлении
      новых функциональностей.
    - **Принцип инверсии зависимостей (Dependency Inversion Principle)**: Синглтон вводит жёсткую зависимость от
      конкретной реализации, что усложняет внедрение зависимостей.

### Источники

- Design Patterns with Java: Singleton
- Введение в паттерны проектирования: Одиночка