# Object Pool

## Пул объектов

**Пул объектов** — это **порождающий** паттерн проектирования, который предоставляет способ управления набором
предварительно созданных объектов, готовых к использованию. Вместо создания новых объектов каждый раз, когда они
необходимы, объекты берутся из пула и возвращаются обратно после использования. Это особенно полезно для объектов,
создание которых дорогостоящее или ресурсоёмкое, например, соединения к базе данных, потоки, сетевые соединения и т.д.

#### Основная идея

Основная идея паттерна Пул объектов заключается в том, чтобы создать ограниченный набор объектов заранее и управлять их
использованием. Когда клиенту требуется объект, он берёт его из пула. После использования объект возвращается в пул для
повторного использования.

#### Применение

Паттерн Пул объектов рекомендуется использовать в следующих случаях:

- **Создание объектов ресурсоёмкое**: Когда создание объектов требует значительных затрат времени или ресурсов (
  например, подключение к базе данных).
- **Необходимость повторного использования объектов**: Когда объекты могут быть переиспользованы без изменения их
  состояния или при минимальном изменении.
- **Ограничение количества экземпляров**: Когда необходимо ограничить количество одновременно используемых объектов для
  предотвращения исчерпания ресурсов.

### Структура паттерна Пул объектов

Паттерн Пул объектов включает в себя следующие компоненты:

1. **ObjectPool (Пул объектов)**: Описание: Класс, который управляет пулом объектов. Отвечает за выдачу объектов
   клиентам и их возвращение в пул.
    - Методы:
        - ```borrowObject()```: Выдаёт объект из пула.
        - ```returnObject(Object obj)```: Принимает объект обратно в пул.
        - ```createObject()```: Создаёт новый объект при необходимости.
2. **Reusable (Повторно используемый)**: Интерфейс или абстрактный класс, который определяет общие методы для объектов,
   управляемых пулом.
3. **ConcreteReusable (Конкретный повторно используемый)**: Класс, реализующий интерфейс Reusable. Представляет
   конкретный тип объектов, управляемых пулом.

### Примеры

#### Пример [Пул подключений к БД](code%2FDatabaseConnection.java)

Рассмотрим пример реализации паттерна Пул объектов для управления соединениями к базе данных. Создадим пул соединений,
который будет предоставлять клиентам соединения из заранее созданного пула и возвращать их обратно после использования.

##### Reusable - Повторно используемый объект

```java
public interface Reusable {
    void reset();
}
```

##### Конкретная реализация повторно используемого объекта

```java
public class DatabaseConnection implements Reusable {
    private boolean inUse;
    private String connectionId;

    public DatabaseConnection(String connectionId) {
        this.connectionId = connectionId;
        this.inUse = false;
        // Симуляция установки соединения
        System.out.println("Соединение " + connectionId + " установлено.");
    }

    public boolean isInUse() {
        return inUse;
    }

    public void connect() {
        if (!inUse) {
            inUse = true;
            System.out.println("Соединение " + connectionId + " используется.");
        } else {
            System.out.println("Соединение " + connectionId + " уже используется.");
        }
    }

    public void disconnect() {
        if (inUse) {
            inUse = false;
            System.out.println("Соединение " + connectionId + " освобождено.");
        }
    }

    @Override
    public void reset() {
        disconnect();
        // Дополнительная очистка состояния соединения при необходимости
        System.out.println("Соединение " + connectionId + " сброшено.");
    }

    public String getConnectionId() {
        return connectionId;
    }
}
```

##### Реализация пула

```java
public class DatabaseConnection implements Reusable {
    private boolean inUse;
    private String connectionId;

    public DatabaseConnection(String connectionId) {
        this.connectionId = connectionId;
        this.inUse = false;
        // Симуляция установки соединения
        System.out.println("Соединение " + connectionId + " установлено.");
    }

    public boolean isInUse() {
        return inUse;
    }

    public void connect() {
        if (!inUse) {
            inUse = true;
            System.out.println("Соединение " + connectionId + " используется.");
        } else {
            System.out.println("Соединение " + connectionId + " уже используется.");
        }
    }

    public void disconnect() {
        if (inUse) {
            inUse = false;
            System.out.println("Соединение " + connectionId + " освобождено.");
        }
    }

    @Override
    public void reset() {
        disconnect();
        // Дополнительная очистка состояния соединения при необходимости
        System.out.println("Соединение " + connectionId + " сброшено.");
    }

    public String getConnectionId() {
        return connectionId;
    }
}
```

### Плюсы данного паттерна

- **Повышение производительности**: Сокращает время на создание и уничтожение объектов, особенно если это ресурсоёмкие
  операции.
- **Эффективное использование ресурсов**: Позволяет ограничить количество одновременно используемых объектов,
  предотвращая исчерпание ресурсов.
- **Управление ресурсами**: Обеспечивает централизованный контроль над использованием объектов.
- **Снижение нагрузки на систему**: Уменьшает количество операций создания и уничтожения объектов, снижая нагрузку на
  сборщик мусора.

### Недостатки данного паттерна

- **Сложность реализации**: Требует дополнительной логики для управления пулом, что может увеличить сложность кода.
- **Необходимость управления состоянием объектов**: Объекты должны быть готовы к повторному использованию, что может
  требовать реализации методов сброса или инициализации.
- **Проблемы с потокобезопасностью**: В многопоточной среде необходимо обеспечить синхронизацию доступа к пулу, что
  может привести к снижению производительности.
- **Скрытые зависимости**: Клиентский код зависит от пула объектов, что может усложнить тестирование и модульность.
