# Factory Method

## Фабричный метод

**Фабричный метод** — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в
суперклассе, позволяя подклассам изменять тип создаваемых объектов.

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор new , а через вызов особого
фабричного метода.

На первый взгляд, это может показаться бессмысленным — мы просто переместили вызов из одного конца программы в другой.
Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта. Чтобы эта
система работала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных
классов, следующих одному и тому же интерфейсу

#### Основная идея

Основная цель паттерна Фабричный метод — **делегировать создание объектов подклассам**, позволяя тем самым изменять тип
создаваемых объектов без изменения кода, который использует эти объекты.

#### Применение

Паттерн Фабричный метод рекомендуется использовать в следующих случаях:

- Когда необходимо определить интерфейс для создания объектов, но оставить выбор конкретных классов подклассам.
- Когда класс не должен знать о конкретных классах создаваемых объектов.
- Когда необходимо обеспечить возможность расширения системы новыми типами объектов без изменения существующего кода.
- Когда процесс создания объекта сложен и включает в себя множество шагов или параметров.

### Реализация

1. Создание общего интерфейса объектов, которые будет создавать производитель и его подкласс.
2. Реализация конкретных продуктов, которую реализуют общей интерфейс.
3. Создание создателя.
4. Создатель объявляет фабричный метод, создающий объекты через общий интерфейс продуктов.
5. Создание конктерных создателей, каждый из которых по своему реализует фабричный метод, производящий те или иные
   продукты.

### Примеры

#### Пример [Transport](code%2Fexample2_transport%2FTransportMain.java)

Создадим систему, которая может создавать различные транспортные средства, такие как автомобили и велосипеды. Используя
паттерн Фабричный метод, мы обеспечим гибкость при добавлении новых типов транспортных средств без изменения
существующего кода.

##### Интерфейс ```Transport```:

```java
/**
 * Общий интерфейс "продукта" - транспорт.
 */
public interface Transport {
    void drive();
}
```

##### Конкретные продукты: ```Car``` и ```Bike```:

```java
/**
 * Конкретный продукт - Car
 */
public class Car implements Transport {
    @Override
    public void drive() {
        System.out.println("Вождение автомобиля.");
    }
}
```

```java
/**
 * Конкретный продукт - Bike
 */
public class Bike implements Transport {
    @Override
    public void drive() {
        System.out.println("Вождение велосипеда.");
    }
}
```

##### Абстрактный создатель ```TransportFactory```:

В общем для абстрактного создателя можно определить как и **абстрактный класс** так и **интерфейс**. Зависит от
ситуации.

```java
/**
 * Абстрактный создатель TransportFactory
 */
public abstract class TransportFactory {
    /**
     * Фабричный метод.
     * Его переопределение будет отвечать за создание разных продуктов.
     *
     * @return созданный продукт
     */
    public abstract Transport createTransport();
}
```

##### Конкретные создатели: ```CarFactory``` и ```BikeFactory```:

```java
/**
 * Конкретный создатель для конкретного продуква - Car
 */
public class CarFactory extends TransportFactory {
    /**
     * Переобпределнный фабричный метод.
     *
     * @return объект Car
     */
    @Override
    public Transport createTransport() {
        return new Car();
    }
}
```

```java
/**
 * Конкретный создатель для конкретного продуква - Bike
 */
public class BikeFactory extends TransportFactory {
    /**
     * Переобпределнный фабричный метод.
     *
     * @return объект Bike
     */
    @Override
    public Transport createTransport() {
        return new Bike();
    }
}
```

##### Класс для тестирования:

Обратите внимание как меняются фабрики по ходу исполнения программы. Одна, наверное, одна из главных причин
использования фабрики - по ходу исполнения в зависимости от выбора мы можем изменять фабрику, при этом методы работы с
ней не изменяются.

```java
/**
 * Пример с подменной фабрик.
 */
public class TransportMain {
    public static void main(String[] args) {
        // Созданили фабрику
        TransportFactory factory = new CarFactory();
        // Создали конкретный продукт - автомобиль
        Transport car = factory.createTransport();

        // Сменили фабрику
        factory = new BikeFactory();
        // Создали конкретный продукт - байк
        Transport bike = factory.createTransport();

        car.drive();
        bike.drive();
    }
}
```

#### Пример [Document](code%2Fexample3_documents%2FDocumentMain.java)

Создадим систему для создания различных типов документов, таких как текстовые документы и PDF-документы. Используя
паттерн Фабричный метод, обеспечим гибкость при добавлении новых типов документов.

##### Интерфейс ```Document```:

```java
/**
 * Общий интерфейс "продукта" - документ.
 */
public interface Document {
    void open();

    void save();
}
```

##### Конкретные продукты: ```WordDocument``` и ```PdfDocument```:

```java
/**
 * Конкретный продукт - WordDocument
 */
public class WordDocument implements Document {
    @Override
    public void open() {
        System.out.println("Открытие Word документа.");
    }

    @Override
    public void save() {
        System.out.println("Сохранение Word документа.");
    }
}
```

```java
/**
 * Конкретный продукт - PdfDocument
 */
public class PdfDocument implements Document {
    @Override
    public void open() {
        System.out.println("Открытие PDF документа.");
    }

    @Override
    public void save() {
        System.out.println("Сохранение PDF документа.");
    }
}
```

##### Абстрактный создатель ```DocumentFactory```:

В отличее от прошлого примера на этот раз абстрактный создатель представлен интерфейсом.

```java
/**
 * Интерфейс абстрактного создателя.
 */
public interface DocumentFactory {
    /**
     * Фабричный метод.
     * Его переопределение будет отвечать за создание разных продуктов.
     *
     * @return созданный продукт
     */
    Document createDocument();
}
```

##### Конкретные создатели: ```PdfDocumentFactory``` и ```DocumentFactory```:

```java
/**
 * Конкретный создатель для конкретного продуква - PdfDocument
 */
public class PdfDocumentFactory implements DocumentFactory {
    /**
     * Переобпределнный фабричный метод.
     *
     * @return объект PdfDocument
     */
    @Override
    public Document createDocument() {
        return new PdfDocument();
    }
}
```

```java
/**
 * Конкретный создатель для конкретного продуква - WordDocument
 */
public class WordDocumentFactory implements DocumentFactory {
    /**
     * Переобпределнный фабричный метод.
     *
     * @return объект WordDocument
     */
    @Override
    public Document createDocument() {
        return new WordDocument();
    }
}
```

##### Класс для тестирования:

```java
public class DocumentMain {
    public static void main(String[] args) {
        // Создание фабрик
        DocumentFactory wordFactory = new WordDocumentFactory();
        DocumentFactory pdfFactory = new PdfDocumentFactory();

        // Использование фабрик для создания документов
        Document wordDoc = wordFactory.createDocument();
        Document pdfDoc = pdfFactory.createDocument();

        // Вызов методов документов
        wordDoc.open();
        wordDoc.save();

        pdfDoc.open();
        pdfDoc.save();
    }
}
```

### Плюсы данного паттерна

- **Гибкость и расширяемость**: Позволяет легко добавлять новые типы продуктов без изменения существующего кода.
- **Снижение связанности**: Клиенты не зависят от конкретных классов продуктов, а работают с абстракциями (Interface или
  Abstract Class).
- **Упрощение кода**: Избавляет от необходимости использовать длинные условные операторы для создания объектов различных
  типов.
- **Соблюдение принципов SOLID**:
    - **Принцип единственной ответственности (Single Responsibility Principle)**: Отделяет процесс создания объектов от
      их использования.
    - **Принцип открытости/закрытости (Open/Closed Principle)**: Классы открыты для расширения, но закрыты для
      модификации.

### Недостатки данного паттерна

- **Увеличение количества классов**: Для каждого типа продукта требуется создать отдельный класс-фабрику, что может
  привести к увеличению числа классов в проекте.
- **Сложность понимания**: Для новичков паттерн может показаться сложным из-за использования абстрактных классов и
  интерфейсов.

### Источники

- Design Patterns with Java: Factory Method
- Введение в паттерны проектирования: Фабричный метод