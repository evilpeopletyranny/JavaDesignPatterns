# Multiton

## Мультитон

Паттерн **Мультитон (Multiton)** представляет собой расширение паттерна **Синглтон (Singleton)**, позволяющее управлять
созданием нескольких экземпляров класса, каждый из которых ассоциирован с уникальным ключом. Это позволяет создавать и
контролировать доступ к ограниченному набору экземпляров, обеспечивая при этом их единственность по ключу.

**Мультитон** — это **порождающий** паттерн проектирования, который управляет созданием и доступом к нескольким
экземплярам класса, каждый из которых идентифицируется уникальным ключом. В отличие от Синглтона, который гарантирует
существование только одного экземпляра класса, Мультитон позволяет создавать ограниченное число экземпляров, доступных
по определённым идентификаторам.

#### Основная идея

Основная идея паттерна Мультитон заключается в том, чтобы контролировать создание экземпляров класса, гарантируя, что
для каждого уникального ключа существует только один экземпляр. Это позволяет эффективно управлять ресурсами и
обеспечивать согласованность данных в рамках разных контекстов.

#### Применение

Паттерн Мультитон рекомендуется использовать в следующих случаях:

- **Необходимость управления ограниченным набором экземпляров класса**: Например, управление соединениями к различным
  базам данных, настройками для разных регионов и т.д.
- **Обеспечение единственности экземпляра по ключу**: Когда требуется, чтобы для каждого уникального идентификатора
  существовал только один экземпляр объекта.
- **Управление ресурсами**: Позволяет эффективно использовать ресурсы, избегая создания избыточных объектов.
- **Согласованность данных**: Гарантирует, что данные в рамках определённого контекста остаются консистентными

### Структура паттерна Мультитон

Паттерн Мультитон включает в себя следующие компоненты:

- Multiton (Мультитон):
    - **Описание**: Класс, реализующий паттерн Мультитон, который управляет созданием и хранением экземпляров.
    - **Особенности**:
        - Приватный конструктор для предотвращения создания экземпляров извне.
        - Статическая коллекция (например, Map) для хранения экземпляров по ключам.
        - Статический метод доступа, принимающий ключ и возвращающий соответствующий экземпляр.

### Примеры

#### Пример[Пример](code%2FShapeFactoryMultiton.java) с фабриками фигур

Предположим, у нас есть различные фигуры: ```Circle```, ```Rectangle``` и ```Triangle```. Для каждой фигуры необходимо
иметь соответствующую фабрику (CircleFactory, RectangleFactory, TriangleFactory), которая отвечает за создание
экземпляров этой фигуры. Используя паттерн Мультитон, мы можем управлять этими фабриками, обеспечивая, что для каждой
фигуры существует только одна фабрика.

##### Интерфейс Продукта

```java
public interface Shape {
    void draw();
}
```

##### Конкретные продукты

```java
public class Circle implements Shape {
    private String name;

    public Circle(String name) {
        this.name = name;
    }

    @Override
    public void draw() {
        System.out.println("Рисование круга: " + name);
    }
}

public class Rectangle implements Shape {
    private String name;

    public Rectangle(String name) {
        this.name = name;
    }

    @Override
    public void draw() {
        System.out.println("Рисование прямоугольника: " + name);
    }
}

public class Triangle implements Shape {
    private String name;

    public Triangle(String name) {
        this.name = name;
    }

    @Override
    public void draw() {
        System.out.println("Рисование треугольника: " + name);
    }
}
```

##### Интерфейс Фабрики

```java
public interface ShapeFactory {
    Shape createShape(String name);
}
```

##### Конкретные фабрики

```java
public class CircleFactory implements ShapeFactory {
    @Override
    public Shape createShape(String name) {
        return new Circle(name);
    }
}

public class RectangleFactory implements ShapeFactory {
    @Override
    public Shape createShape(String name) {
        return new Rectangle(name);
    }
}

public class TriangleFactory implements ShapeFactory {
    @Override
    public Shape createShape(String name) {
        return new Triangle(name);
    }
}
```

##### Мультитон

```java
public class ShapeFactoryMultiton {
    private static final Map<ShapeType, ShapeFactory> instance = new EnumMap<>(ShapeType.class);

    static {
        instance.put(CIRCLE, new CircleFactory());
        instance.put(RECTANGLE, new RectangleFactory());
        instance.put(TRIANGLE, new TriangleFactory());
    }

    // Приватный конструктор для предотвращения создания экземпляров
    private ShapeFactoryMultiton() {
    }

    // Статический метод доступа
    public static synchronized ShapeFactory getInstance(ShapeType type) {
        return instance.get(type);
    }
}
```

### Плюсы данного

- **Контроль над количеством экземпляров**: Позволяет ограничить количество экземпляров класса, обеспечивая
  единственность для каждого ключа.
- **Гибкость и расширяемость**: Легко добавлять новые типы экземпляров без изменения существующего кода.
- **Эффективное управление ресурсами**: Избегает избыточного создания объектов, что может быть важно при работе с
  ресурсозатратными объектами (например, соединениями к базе данных).
- **Согласованность данных**: Гарантирует, что все части программы используют одни и те же экземпляры для одного ключа,
  обеспечивая консистентность данных.

### Недостатки данного паттерна

- **Сложность реализации**: Требует дополнительной логики для управления экземплярами и ключами.
- **Скрытые зависимости**: Клиентский код зависит от конкретных ключей, что может усложнить понимание зависимостей и
  тестирование.
- **Проблемы с тестированием**: Могут возникнуть сложности при написании юнит-тестов из-за глобального состояния и
  управляемого количества экземпляров.
- **Необходимость управления жизненным циклом**: Требует дополнительных механизмов для управления жизненным циклом и
  уничтожением экземпляров, если это необходимо.
