<h1 align="center">
   Adapter
</h1>
<h3 align="center">
   Адаптер
</h3>

**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать
вместе.


<h3 align="center">
   Варианты реализации
</h3>

Адаптер можно реализовать двумя способами:

- Основанном на классах. При этом используется наследование.
- Основанном на объектах. При этом используется композиция.

Оба подхода описаны в предлагаемых книгах.

В данном случае мы будем рассматривать подход основанный на композиции. Данный подход предпочтительней, так как:

- Наследование создает жесткую связь с классом родителя.
- Изменение класса родителя может влиять на адаптер.
- Класс не всегда можно унаследовать.
- Композиция позволяет добиться большей гибкости.

<h3 align="center">
   Реализация
</h3>

1. Убедитесь, что у вас есть два класса с неудобными интерфейсами:
    - *полезный сервис* — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой
      код);
    - *один или несколько клиентов* — классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего
      интерфейса.
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать сторонний класс.
3. Создайте класс адаптера, реализовав этот интерфейс.
4. Поместите в адаптер поле-ссылку на объект-сервис. В большинстве случаев, это поле заполняется объектом, переданным в
   конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису
6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять
   адаптеры в будущем.

<h3 align="center">
   Adapter UML-диаграмма
</h3>

<p align="center">
   <img src=https://github.com/evilpeopletyranny/JavaDesignPatterns/blob/main/src/patterns/structural/adapter/diagram.png alt="adapter uml">
</p>

<h3>Плюсы</h3>

- Отделяет и скрывает от клиента подробности преобразования различных интерфейсов.

<h3>Минусы</h3>

- Усложняет код программы за счёт дополнительных классов.

<h3 align="center">
   Примеры
</h3>

- [Адаптирование сортировки списка к сортировке массива.](https://github.com/evilpeopletyranny/JavaDesignPatterns/tree/main/src/patterns/structural/adapter/code/sort)
- [Конвертор данных от БД через JDBC в виде Адаптера.](https://github.com/evilpeopletyranny/JavaDesignPatterns/tree/main/src/patterns/structural/adapter/code/JDBCexample)
  Пример очень надуманный, но надеюсь поможет студентам, которые захотели использовать БД. *Суть в том, чтобы
  использовать JDBC как **полезный сервис***.
- [Habr: Java Adapter Pattern in Game Server](https://habr.com/ru/articles/577220/)
- [JavaRush: Паттерн проектирования Адаптер](https://javarush.com/groups/posts/2139-pattern-proektirovanija-adapter)
- [Шаблон адаптера в Java](https://for-each.dev/lessons/b/-java-adapter-pattern) пример использования Адаптера для
  конвертации данных.
- Яркий пример адаптера из стандартной библиотеки *Java* это JDBC для работы с БД. JDBC - Драйверы
  JDBC - это адаптеры на стороне клиента (установленные на клиентском компьютере, а не на
  сервере), которые преобразуют запросы от программ Java в протокол, понятный СУБД.
    <p align="center">
        <img src=https://github.com/evilpeopletyranny/JavaDesignPatterns/blob/main/src/patterns/structural/adapter/JDBC.png alt="jdbc adapter">
    </p>

<h5 align="center">
   Замечания
</h5>

**Не путать с фасадом!!**

- И там и там представляется доступ к какой-то системе, которая скрыта от клиента. Основное различие заключается в
  целевом
  направлении. В случае с фасадом целью было облегчить доступ к сложной или запутанной системе. Задача адаптера -
  обеспечить взаимодействие двух систем друг с другом в первую очередь. Отсюда вытекает еще одно очевидное различие: кто
  создает абстракцию? В случае с фасадом было ясно, что поставщик системы должен создать фасад; он обеспечивает
  упрощенную
  обработку. С адаптером обычно все иначе. Поставщик системы вкладывает много времени и усилий в создание своего
  программного обеспечения. Он разрабатывает интерфейс, в который клиент может направлять свои запросы. На этом его
  работа
  закончена. Если клиенту нужен другой интерфейс, он должен создать его и определить адаптер.

- В большинстве случаев Адаптер - это класс, который был написан и оптимизирован для одного случая использования.

- В библиотеки разработки GUI на Java - **SWING** есть множество классов и интерфейсов с припиской Adapter. Но самом
  деле они такими не являются. Поскольку они скрывают сложную систему взаимодействия с переферийными устройтсвами и
  предоставляют удобный интерфейс для взаимодействия, то правильно их скорее назвать **Фасадами**, а не **Адаптерами
  **. :grin:

<h3 align="center">
   Источники
</h3>

- Design Patterns with
  Java: [Adapter](https://github.com/evilpeopletyranny/JavaDesignPatterns/blob/main/src/patterns/structural/adapter/books/Olaf%20Musch%20EN.pdf)
- Введение в паттерны
  проектирования: [Адаптер](https://github.com/evilpeopletyranny/JavaDesignPatterns/blob/main/src/patterns/structural/adapter/books/Alexander%20Shvets%20RU.pdf)
- [Habr: Java Adapter Pattern in Game Server](https://habr.com/ru/articles/577220/)
- [JavaRush: Паттерн проектирования Адаптер](https://javarush.com/groups/posts/2139-pattern-proektirovanija-adapter)
- [Шаблон адаптера в Java](https://for-each.dev/lessons/b/-java-adapter-pattern) пример использования Адаптера для
  конвертации данных.