<h1 align="center">
    Многопоточность. Основные понятия.
</h1>

<h2 align="center">
    Введение
</h2>

### Организация материала

Теоретические аспекты, необходимые для выполнения лабораторных работ разделены на 5 частей, читать которые предлагается
последовательно. Все примеры, связанные с каждой из теоретических частей находятся в соответствующих папках, однако в
тех местах, где они упоминаются, на них предусмотрены ссылки.

В отдельную часть вынесены описания модулей дополнительных элементов многопоточности. Они не являются обязательными для
освоения курса, но требуются для более глубокого, современного взгляда на использование параллелизма в
программировании.

<h2 align="center">
    Модели
</h2>

По большому счёту, для понимания многопоточности нужно не так уж много, поэтому в начале
будет описан набор сильно упрощённых для понимания моделей, после чего, в процессе рассказа о конкретных аспектах
многопоточности часть из них будет заменяться более подробными описаниями.

### Поток

Чаще всего в ваших программах поток один — тот, точкой входа которого является функция ` main() `
Задача многопоточности сводится к тому, чтобы выполнять вычисления независимо от потока `main` в других потоках.
Если обобщать, то **поток — это единица _исполнения_ кода**

### Процессор

Для нас представляет собой чёрный ящик, исполняющий код. Для нас не имеет значения, одноядерный наш процессор, или нет.

### Процесс

Контейнер, содержащий в себе контекст исполнения программы (код, данные, привилегии, объекты ОС... - всё то
что необходимо для исполнения программы в рамках операционной системы) Каждый процесс содержит в себе один или более
потоков.

### Операционная система

В контексте многопоточности, для нас важно, что ОС:

1. Создаёт объекты потоков и передаёт их в пользование процессам.
2. Определяет порядок выделения процессорного времени для каждого потока

### Порядок исполнения потоков

Поскольку потоков даже в рамках одного приложения может быть довольно много, возникает вопрос: как же они могут
исполняться на единственном ядре процессора?

Для этого используется механизм **квантования времени**. Представлять себе это можно как приоритетную очередь, в которую
выстроены все потоки, существующие в системе. Сверху этой очереди берётся поток и начинается его исполнение на
процессоре. Его исполнение продолжается в течение жестко фиксированного времени, называемого **квантом**.
После завершения выделенного кванта времени, поток возвращается в приоритетную очередь, а с её верху берётся следующий
поток и всё повторяется.

Величина кванта чаще всего связана с определённым числом тактов процессора.

Практическое следствие квантования времени состоит в том, что в процессе разработки приложения невозможно определить,
в какой момент времени конкретный поток будет вытеснен, или наоборот получит процессорное время.

Причём важно учитывать, что код перед исполнением так или иначе транслируется в набор операций и в конечном итоге,
исполнение может быть прервано между любыми двумя операциями. То есть, например, выражение `a = (b-c)*(d-b)`
вполне может быть прервано после вычисления первой разности, но до вычисления второй — посреди строчки.

<h2 align="center">
    Рассматриваемые аспекты
</h2>

- Создание и запуск потоков параллельно с main.
- Определение последствий, вызванных порядком исполнения потоков и использование механизмов синхронизации для борьбы с
  этими последствиями.
- Рассмотрение типовых задач при использовании многопоточности и методов их решения.

[Создание потоков](DocVers/2.ThreadCreation.md)