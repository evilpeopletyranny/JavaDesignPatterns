# Обедающие философы

Задача об **Обедающих Философах (Dining Philosophers Problem)** — это классическая проблема синхронизации в области
многопоточности и параллельных вычислений, предложенная Эдгаром Дейкстрой в 1965 году. Она используется для иллюстрации
проблем и решений, связанных с распределением ограниченных ресурсов среди конкурирующих процессов.

## Сценарий

Представьте круглый стол, за которым сидят пять философов. Каждый философ чередует периоды размышлений и еды. Перед
каждым философом расположены две вилки — левая и правая. Для того чтобы поесть, философу необходимо одновременно
захватить обе вилки (левую и правую). После еды философ кладет вилки обратно на стол и возвращается к размышлениям.

## Главная цель задачи

Основная цель задачи об Обедающих Философах — разработать механизм синхронизации, который позволит всем философам
регулярно есть, избегая при этом **Deadlock** (взаимной блокировки) и **Starvation** (голодания отдельных философов).
Это означает:

1. **Отсутствие Deadlock**: Система не должна застревать в состоянии, где каждый философ удерживает одну вилку и ждет
   другую, создавая циклическую зависимость.
2. **Отсутствие Starvation**: Каждый философ должен иметь возможность есть через конечное время, без бесконечного
   ожидания.
3. **Эффективное использование ресурсов**: Вилки не должны простаивать, если они могут быть использованы для еды.

## [Пример](code%2FMain.java) решения задачи

В этом примере мы реализуем задачу об Обедающих Философах, используя базовое средство синхронизации -
монитор (```synchronized```). применим **стратегию упорядоченного захвата ресурсов**, чтобы избежать **Deadlock**.

---

Класс вилки ```Fork```. Каждая вилка имеет уникальный идентификатор (```id```), который используется для упорядоченного
захвата.

```java
public class Fork {
    private final int id;

    public Fork(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }
}
```

---

Класс философа ```Philosopher```. Каждый философ знает свои две вилки: ```firstFork``` и ```secondFork```. Чтобы
избежать **Deadlock**, философы захватывают вилки в порядке увеличения их идентификаторов. Исключение составляет
последний философ, который меняет порядок захвата вилок.

```java
// Класс, представляющий философа
class Philosopher implements Runnable {
    private final int id;
    private final Fork firstFork;
    private final Fork secondFork;
    private final Random random;

    public Philosopher(int id, Fork leftFork, Fork rightFork) {
        this.id = id;
        // Упорядоченный захват вилок
        if (leftFork.getId() < rightFork.getId()) {
            this.firstFork = leftFork;
            this.secondFork = rightFork;
        } else {
            this.firstFork = rightFork;
            this.secondFork = leftFork;
        }
        this.random = new Random();
    }

    @Override
    public void run() {
        try {
            while (true) {
                think();
                eat();
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Философ " + (id + 1) + " завершил работу.");
        }
    }

    private void think() throws InterruptedException {
        System.out.println("Философ " + (id + 1) + " размышляет.");
        Thread.sleep(random.nextInt(8000)); // Философ размышляет некоторое время
    }

    private void eat() throws InterruptedException {
        // Захват первой вилки
        synchronized (firstFork) {
            System.out.println("Философ " + (id + 1) + " взял вилку " + firstFork.getId() + ".");

            // Захват второй вилки
            synchronized (secondFork) {
                System.out.println("Философ " + (id + 1) + " взял вилку " + secondFork.getId() + ".");
                System.out.println("Философ " + (id + 1) + " начинает есть.");
                Thread.sleep(random.nextInt(8000)); // Философ ест некоторое время
                System.out.println("Философ " + (id + 1) + " закончил есть.");
            }
            System.out.println("Философ " + (id + 1) + " положил вилку " + secondFork.getId() + ".");
        }
        System.out.println("Философ " + (id + 1) + " положил вилку " + firstFork.getId() + ".");
    }
}
```

---

```java
public class Main {
    public static void main(String[] args) {
        int numberOfPhilosophers = 5;
        List<Philosopher> philosophers = new ArrayList<>(numberOfPhilosophers);
        List<Fork> forks = new ArrayList<>(numberOfPhilosophers);

        // Инициализация вилок
        for (int i = 0; i < numberOfPhilosophers; i++) forks.add(new Fork(i));

        // Инициализация философов и запуск потоков
        for (int i = 0; i < numberOfPhilosophers; i++) {
            Fork leftFork = forks.get(i);
            Fork rightFork = forks.get((i + 1) % numberOfPhilosophers);

            // Чтобы избежать симметрии, последний философ меняет порядок захвата вилок
            if (i == numberOfPhilosophers - 1) philosophers.add(new Philosopher(i, rightFork, leftFork));
            else philosophers.add(new Philosopher(i, leftFork, rightFork));

            //Запуск потоков с философами
            new Thread(philosophers.get(i), "Философ " + (i + 1)).start();
        }
    }
}
```

### Стратегия предотвращения Deadlock:

**Упорядоченный захват ресурсов**: Все философы, кроме последнего, сначала захватывают левую вилку, затем правую.
Последний философ сначала захватывает правую вилку, затем левую. Это устраняет циклическую зависимость.

### Поведение потоков:

Философы циклично выполняют действия размышления и еды. Во время еды философ захватывает обе вилки, имитирует процесс
еды и затем освобождает вилки.

### Поведение потоков:

Используются блоки synchronized для захвата вилок, обеспечивая, что только один философ может держать вилку в конкретный
момент времени.

## Пример вывода

```
Философ 1 размышляет.
Философ 4 размышляет.
Философ 2 размышляет.
Философ 5 размышляет.
Философ 3 размышляет.
Философ 1 взял вилку 0.
Философ 1 взял вилку 1.
Философ 1 начинает есть.
Философ 4 взял вилку 3.
Философ 4 взял вилку 4.
Философ 4 начинает есть.
Философ 3 взял вилку 2.
Философ 4 закончил есть.
Философ 4 положил вилку 4.
Философ 3 взял вилку 3.
Философ 3 начинает есть.
Философ 4 положил вилку 3.
Философ 4 размышляет.
Философ 3 закончил есть.
Философ 3 положил вилку 3.
```

## Альтернативные подходы к решению

Помимо упорядоченного захвата ресурсов, существует несколько других стратегий предотвращения Deadlock в задаче об
Обедающих Философах:

1. Использование ограниченного числа вилок: Например, ограничение числа одновременно берущих вилки философов до четырех
   из пяти. Это гарантирует, что по крайней мере один философ может всегда есть, предотвращая Deadlock.
2. Использование тайм-аутов: Если философ не может захватить вилку в течение определённого времени, он освобождает уже
   захваченные вилки и пытается снова позже. Это предотвращает циклические зависимости, но может приводить к Starvation,
   если философы постоянно неудачно захватывают вилки.

## Заключение

Задача об Обедающих Философах — это полезная модель для понимания проблем синхронизации и распределения ресурсов в
многопоточных приложениях. Применение стратегий, таких как упорядоченный захват ресурсов или использование
дополнительного контроля доступа, позволяет эффективно предотвращать Deadlock и обеспечивать справедливое распределение
ресурсов среди конкурирующих потоков.

При разработке многопоточных приложений важно тщательно проектировать механизмы синхронизации, учитывать возможные
состояния блокировки и применять подходящие стратегии для обеспечения стабильной и надёжной работы системы.
