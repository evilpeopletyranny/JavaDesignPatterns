# Спящие Брадобреи

Задача об Спящих Брадобреях (Sleeping Barber Problem) — это классическая проблема синхронизации в области
многопоточности и распределённых систем, предложенная Эдгаром Дейкстрой в 1965 гоуду. Она служит для иллюстрации проблем
управления ресурсами и синхронизации между потоками при ограниченном количестве ресурсов.

## Сценарий

Представьте, что есть барбершоп с одним барбером, одним креслом для стрижки и несколькими креслами для ожидания. Барбершоп работает следующим образом:

1. Барбер:
    - Если нет клиентов, барбер засыпает.
    - Когда клиент приходит, барбер просыпается и начинает стрижку.
2. Клиент:
    - Если барбер спит и кресло для стрижки свободно, клиент будит барбера и получает стрижку.
    - Если барбер занят, клиент садится на свободное кресло в зоне ожидания.
    - Если все кресла для ожидания заняты, клиент уходит, не получив стрижки.

## Главная цель задачи

Основная цель задачи об Спящих Брадобреях — разработать механизм синхронизации между потоками клиентов и парикмахера, который обеспечит:

1. **Эффективное использование ресурсов**: Барбер не простаивает без необходимости. Клиенты получают стрижку, если есть свободные ресурсы (барбер и кресло).
2. **Избежание состояний гонки (Race Conditions)**: Корректное управление доступом к общим ресурсам (барбер и кресло для стрижки).
3. **Предотвращение Deadlock**: Обеспечение того, чтобы система не застревала в состоянии взаимной блокировки.
4. **Обработка ограниченных ресурсов**: Управление числом кресел для ожидания, чтобы клиенты могли или ждать, или уходить при отсутствии свободных мест.

## [Пример](code%2FMain.java) решения задачи

- **Барбершоп (```BarberShop```):**
  - Управляет взаимодействием между парикмахером и клиентами.
  - Содержит количество доступных кресел для ожидания.

```java
public class BarberShop {
   private final int numSeats;
   private final Queue<Customer> waitingCustomers;
   private boolean isBarberSleeping;

   public BarberShop(int numSeats) {
      this.numSeats = numSeats;
      this.waitingCustomers = new LinkedList<>();
      this.isBarberSleeping = true;
   }

   // Метод, вызываемый клиентом при входе в Барбершоп
   public synchronized void enterShop(Customer customer) {
      System.out.println(customer.getName() + " вошёл в барбершоп.");

      if (waitingCustomers.size() == numSeats) {
         // Нет свободных кресел для ожидания
         System.out.println(customer.getName() + " не нашёл свободных мест и ушёл.");
         return;
      } else {
         // Есть место для ожидания
         waitingCustomers.add(customer);
         System.out.println(customer.getName() + " сел в кресло для ожидания.");

         // Если парикмахер спит, разбудить его
         if (isBarberSleeping) {
            System.out.println(customer.getName() + " разбудил парикмахера.");
            notify(); // Уведомляем парикмахера о приходе клиента
         }
      }
   }

   // Метод, вызываемый парикмахером для выполнения стрижки
   public synchronized Customer nextCustomer() {
      while (waitingCustomers.isEmpty()) {
         try {
            System.out.println("Парикмахер спит, ожидает клиентов...");
            isBarberSleeping = true;
            wait(); // Парикмахер засыпает и ждёт клиентов
         } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Парикмахер прерван.");
            return null;
         }
      }
      isBarberSleeping = false;
      return waitingCustomers.poll();
   }
}
```

- ```numSeats```: количество кресел для ожидания.
- ```waitingCustomers```: очередь ожидающих клиентов.
- ```isBarberSleeping```: флаг, указывающий, спит ли парикмахер.

- ```enterShop(Customer customer)```: вызывается клиентом при входе в барбершоп. Если есть свободное кресло для ожидания, клиент садится; иначе уходит. Если парикмахер спит, клиент его будит.
- ```nextCustomer()```: вызывается барбером для получения следующего клиента. Если нет клиентов, парикмахер засыпает и ждёт уведомления.

---

- Парикмахер (```Barber```):
  - Ждёт клиентов.
  - Выполняет стрижки.

```java
public class Barber implements Runnable {
    private final BarberShop shop;

    public Barber(BarberShop shop) {
        this.shop = shop;
    }

    @Override
    public void run() {
        while (true) {
            Customer customer = shop.nextCustomer();
            if (customer != null) {
                cutHair(customer);
            }
        }
    }

    private void cutHair(Customer customer) {
        System.out.println("Парикмахер начинает стричь " + customer.getName() + ".");
        try {
            Thread.sleep(2000); // Имитация времени стрижки
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            System.out.println("Стрижка прервана.");
        }
        System.out.println("Парикмахер закончил стричь " + customer.getName() + ".");
    }
}
```

- ```shop```: ссылка на барбершоп.

- ```run()```: основной цикл парикмахера, который постоянно пытается получить клиента и выполнять стрижку.
- ```cutHair(Customer customer)```: имитирует процесс стрижки клиента.

---

- **Клиент (```Customer```):**
   - Пытается получить стрижку.
   - Если есть свободное кресло для ожидания, садится и ждёт.
   - Иначе уходит.

```java
public class Customer implements Runnable {
    private final String name;
    private final BarberShop shop;

    public Customer(String name, BarberShop shop) {
        this.name = name;
        this.shop = shop;
    }

    public String getName() {
        return name;
    }

    @Override
    public void run() {
        shop.enterShop(this);
    }
}
```

- ```name```: имя клиента.
- ```shop```: ссылка на барбершоп.

- ```run()```: клиент пытается войти в барбершоп.

---

```java
public class Main {
    public static void main(String[] args) {
        BarberShop shop = new BarberShop(3); // Барбершоп с 3 креслами для ожидания
        Thread barberThread = new Thread(new Barber(shop), "Парикмахер");
        barberThread.start();

        // Создаём и запускаем клиентов
        for (int i = 1; i <= 10; i++) {
            Customer customer = new Customer("Клиент-" + i, shop);
            Thread customerThread = new Thread(customer, "Клиент-" + i);
            customerThread.start();

            try {
                Thread.sleep(100); // Интервал между приходами клиентов
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

- Создаётся барбершоп с тремя креслами для ожидания.
- Запускается поток барбера.
- Создаются и запускаются десять потоков клиентов с интервалом  между ними.

## Пример вывода:

```
Парикмахер спит, ожидает клиентов...
Клиент-1 вошёл в барбершоп.
Клиент-1 сел в кресло для ожидания.
Клиент-1 разбудил парикмахера.
Парикмахер начинает стричь Клиент-1.
Клиент-2 вошёл в барбершоп.
Клиент-2 сел в кресло для ожидания.
Клиент-3 вошёл в барбершоп.
Клиент-3 сел в кресло для ожидания.
Клиент-4 вошёл в барбершоп.
Клиент-4 сел в кресло для ожидания.
Клиент-5 вошёл в барбершоп.
Клиент-5 не нашёл свободных мест и ушёл.
Парикмахер закончил стричь Клиент-1.
Парикмахер начинает стричь Клиент-2.
Клиент-6 вошёл в барбершоп.
Клиент-6 сел в кресло для ожидания.
Парикмахер закончил стричь Клиент-2.
Парикмахер начинает стричь Клиент-3.
Клиент-7 вошёл в барбершоп.
Клиент-7 сел в кресло для ожидания.
Парикмахер закончил стричь Клиент-3.
Парикмахер начинает стричь Клиент-4.
Клиент-8 вошёл в барбершоп.
Клиент-8 не нашёл свободных мест и ушёл.
Парикмахер закончил стричь Клиент-4.
Парикмахер начинает стричь Клиент-6.
Клиент-9 вошёл в барбершоп.
Клиент-9 не нашёл свободных мест и ушёл.
Клиент-10 вошёл в барбершоп.
Клиент-10 не нашёл свободных мест и ушёл.
Парикмахер закончил стричь Клиент-6.
Парикмахер начинает стричь Клиент-7.
Парикмахер закончил стричь Клиент-7.
Парикмахер спит, ожидает клиентов...
```

## Альтернативные подходы к решению

1. **Использование ```Semaphore```:** Вместо ручного управления очередью клиентов и синхронизацией, можно использовать семафоры для ограничения числа одновременных клиентов.
2. **Использование высокоуровневых классов из ```java.util.concurrent```:** ```BlockingQueue``` для управления очередью клиентов.




