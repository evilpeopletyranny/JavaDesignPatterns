# Создание потоков

В Java есть несколько способов создания и запуска потоков для выполнения параллельных задач. Основными из них являются:

1. Наследование от класса ```Thread```.
2. Реализация интерфейса ```Runnable```.
3. Реализация интерфейса ```Callable```.

Каждый из этих способов имеет свои особенности и применяется в разных ситуациях.

# Наследование от класса [Thread](code%2FThreadMain.java)

Наследование от класса ```Thread``` — это самый прямой способ создания нового потока в Java. Вы создаете класс, который
расширяет класс ```Thread```, и переопределяете метод ```run()```, который содержит код, выполняемый в новом потоке.

```java
class MyThread extends Thread {
    @Override
    public void run() {
        // Код, который будет выполняться в новом потоке
        System.out.println("Поток " + Thread.currentThread().getName() + " выполняется.");
        // Например, выполнить какую-то задачу
        for (int i = 1; i <= 5; i++) {
            System.out.println("Поток " + Thread.currentThread().getName() + ": значение i = " + i);
            try {
                Thread.sleep(500); // Приостановка потока на 500 миллисекунд
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Поток " + Thread.currentThread().getName() + " завершён.");
    }
}

public class ThreadMain {
    public static void main(String[] args) {
        MyThread thread1 = new MyThread(); // Создание экземпляра потока
        thread1.setName("МойПоток-1");     // Установка имени потока

        MyThread thread2 = new MyThread();
        thread2.setName("МойПоток-2");

        thread1.start(); // Запуск потока
        thread2.start();
    }
}
```

- **Простота**: Наследование от ```Thread``` позволяет непосредственно использовать методы и свойства
  класса ```Thread```.
- **Ограничение**: В Java нет множественного наследования классов. Если ваш класс уже наследуется от другого класса, вы
  не сможете наследоваться от ```Thread```.

# Реализация интерфейса [Runnable](code%2FThreadMain.java)

Реализация интерфейса ```Runnable``` является более гибким способом создания потоков. Интерфейс ```Runnable``` содержит
единственный метод ```run()```, который нужно реализовать. Затем вы создаете объект ```Thread```, передавая ему
экземпляр вашего класса ```Runnable```.

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // Код, который будет выполняться в новом потоке
        System.out.println("Поток " + Thread.currentThread().getName() + " выполняется.");
        // Например, выполнить какую-то задачу
        for (int i = 1; i <= 5; i++) {
            System.out.println("Поток " + Thread.currentThread().getName() + ": значение i = " + i);
            try {
                Thread.sleep(500); // Приостановка потока на 500 миллисекунд
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("Поток " + Thread.currentThread().getName() + " завершён.");
    }
}

public class RunnableMain {
    public static void main(String[] args) {
        Runnable runnable = new MyRunnable(); // Создание экземпляра Runnable

        Thread thread1 = new Thread(runnable, "МойПоток-1"); // Создание потока с именем
        Thread thread2 = new Thread(runnable, "МойПоток-2");

        thread1.start(); // Запуск потока
        thread2.start();
    }
}
```

- **Гибкость**: Поскольку вы реализуете интерфейс, ваш класс может наследоваться от другого класса.
- **Разделение задач**: Код выполнения (```Runnable```) отделен от кода управления потоком (```Thread```), что улучшает
  архитектуру приложения.

## Внимание!!!

Переопределен метод `run()`, а вызывается метод `start()`. При вызове метода `run()`,
он запустится на исполнение в потоке `main`.

# Реализация интерфейса [Callable](code%2FCallableMain.java)

**Информация об интерфейсе Callable является в большей _степени справочной_. В своих работах вы можете обойтись
только ```Thread``` и ```Runnable```.**

```Callable``` — это интерфейс в Java из пакета ```java.util.concurrent```, который позволяет определить задачу,
возвращающую результат и способную бросать исключения. В отличие от интерфейса ```Runnable```, метод ```call()```
интерфейса ```Callable``` может возвращать значение и бросать проверяемые исключения.

```java
class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        // Логика задачи
        return "Результат задачи, полученный из Callable";
    }
}

public class CallableMain {
    public static void main(String[] args) throws Exception {
        ExecutorService executorService = Executors.newSingleThreadExecutor();
        MyCallable callableTask = new MyCallable();

        Future<String> future = executorService.submit(callableTask);

        // Получение результата
        String result = future.get();
        System.out.println("Результат: " + result);

        executorService.shutdown();
    }
}
```

- **ExecutorService**: Интерфейс для управления пулом потоков и выполнения асинхронных задач.
- **Future**: Объект, представляющий результат асинхронного вычисления. Метод ```get()``` блокирует поток до получения
  результата.
- **submit()**: Метод, принимающий ```Callable``` и возвращающий ```Future```.

## Когда использовать Callable

- Когда необходимо выполнить задачу в отдельном потоке и получить результат.
- Если требуется обработать исключения, возникающие во время выполнения задачи.

## Преимущества использования Callable

- **Возврат результата**: Возможность получить результат выполнения задачи.
- **Обработка исключений**: Метод ```call()``` может бросать проверяемые исключения.
- **Совместимость с ExecutorService**: Легко интегрируется с API для управления потоками.

# Соответсвие Java поток и потоков ОС

В современных реализациях Java Virtual Machine (JVM) Java-потоки обычно реализуются с использованием нативных потоков
операционной системы (ОС).

Когда вы создаете и запускаете новый поток в Java с помощью класса ```Thread``` или через ```ExecutorService```, JVM
создает соответствующий нативный поток ОС. Это означает, что каждый Java-поток сопоставлен один-к-одному с потоком
операционной системы. Такая модель позволяет JVM использовать возможности многозадачности и многопоточности,
предоставляемые ОС, включая планирование потоков, управление приоритетами и распределение на разные ядра процессора.

## Подробности реализации

- **Создание потока**: Вызов метода ```start()``` на объекте ```Thread``` инициирует создание нового нативного потока ОС
  через системные вызовы.

```
Thread thread = new Thread(() -> {
    // Код, выполняемый в новом потоке
});
thread.start(); // Создает нативный поток ОС
```

- **Планирование и управление**: Операционная система отвечает за планирование выполнения потоков, распределяя их по
  доступным процессорам и ядрам.

## Исторический контекст

- **Зелёные потоки (Green Threads)**: В ранних версиях JVM (до Java 1.2) использовались зелёные потоки, которые
  эмулировались на уровне JVM и не соответствовали нативным потокам ОС. Это ограничивало производительность и не
  позволяло использовать преимущества многопроцессорных систем.
- **Переход на нативные потоки**: Начиная с Java 1.2, JVM перешла на использование нативных потоков ОС для улучшения
  производительности и масштабируемости.

# Прерывание потоков

В Java безопасное и контролируемое завершение потока может быть достигнуто с помощью механизма
прерываний (```interruptions```). **Прерывание потока** — это способ сообщить потоку, что ему следует прекратить свою
работу. Это особенно важно, когда поток выполняет длительную или бесконечную задачу, и необходимо иметь возможность
корректно остановить его выполнение.

**Прерывание потока** — это сигнал, который отправляется потоку, чтобы указать, что ему следует прекратить выполнение.
Прерывание не заставляет поток немедленно остановиться; вместо этого поток должен сам проверить, был ли он прерван, и
корректно завершить свою работу.

## Как работает прерывание потока?

1. **Отправка сигнала прерывания**: Используется метод ```interrupt()``` у объекта ```Thread```.

```
thread.interrupt();
```

2. **Обработка прерывания в потоке**:
    - Поток должен периодически проверять, был ли он прерван, с помощью методов ```Thread.interrupted() ```
      или ```isInterrupted()```.
    - Если поток находится в состоянии ожидания (например, вызовы ```sleep()```, ```wait()```, ```join()```), то при
      прерывании будет выброшено ```InterruptedException```.
