# Синхронизация потоков

**Синхронизация потоков** — это механизм, позволяющий контролировать доступ к общим ресурсам в многопоточных
приложениях, чтобы предотвратить конфликтные ситуации и обеспечить целостность данных. В многопоточном программировании
несколько потоков могут одновременно обращаться к общим переменным или объектам, что может привести к некорректному
поведению программы, если доступ не контролируется.

## Зачем нужна синхронизация?

- **Предотвращение гонок данных (Data Races)**: Когда два или более потока одновременно читают и записывают общие данные
  без надлежащей координации, результат может быть непредсказуемым.

- **Обеспечение атомарности операций**: Некоторые операции должны выполняться как неделимые, чтобы данные оставались
  консистентными.

- **Управление последовательностью выполнения**: Иногда необходимо, чтобы один поток ждал завершения другого или
  выполнял действия в определенном порядке.

## Когда необходима синхронизация

1. **Общий изменяемый ресурс.** Переменные и объекты, которые изменяются несколькими потоками. _Пример: Счетчик, который
   увеличивается разными потоками._
2. **Коллекции без потокобезопасности.** Использование коллекций из ```java.util``` (
   например, ```ArrayList```, ```HashMap```) без синхронизации может привести к неконсистентным данным.
3. **Чтение и запись в общий файл или базу данных.** Необходимо контролировать доступ, чтобы избежать повреждения
   данных.
4. **Операции, зависящие от текущего состояния.** Когда выполнение операции зависит от определенного состояния объекта,
   которое может быть изменено другими потоками.
5. **Потокобезопасные операции с изменяемыми данными.** Например, проверка и установка значения в одном атомарном
   действии.

## Когда синхронизация не требуется

1. **Иммутабельные объекты.** Объекты, состояние которых не меняется после создания, безопасны для использования в
   нескольких потоках без синхронизации. Пример: _Объекты
   класса ```String```, пользовательские неизменяемые классы._
2. **Локальные переменные внутри методов.** Каждый поток имеет свой собственный стек, поэтому локальные переменные
   методов являются потокобезопасными.
3. **Коллекции и объекты, созданные и используемые внутри одного потока.** Если объект не доступен другим потокам,
   синхронизация не требуется.
4. **Потокобезопасные классы из java.util.concurrent
   **. ```ConcurrentHashMap```, ```CopyOnWriteArrayList```, ```BlockingQueue``` и тд.

## Рекомендации по использованию синхронизации потоков

1. **Минимизируйте область синхронизации.** Синхронизируйте только необходимые участки кода, чтобы избежать снижения
   производительности.
2. **Избегайте долгих операций внутри синхронизированных блоков.** Это может привести к блокировкам и снижению
   отзывчивости приложения.
3. **Используйте высокоуровневые конструкции из ```java.util.concurrent```**. Они предоставляют более эффективные и
   удобные средства для управления потоками и синхронизации.
4. **Проектируйте классы как неизменяемые, если это возможно.** Это значительно упрощает многопоточное программирование.
5. **Будьте осторожны с мертвыми блокировками (deadlocks)**. Избегайте ситуаций, когда потоки навсегда блокируют друг
   друга.