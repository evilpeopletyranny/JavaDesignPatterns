# Синхронизация выполнения потоков

В Java метод ```join()``` является средством управления потоками, позволяющим одному потоку ждать завершения другого. Он
предоставляет способ синхронизировать выполнение потоков, обеспечивая, что определенный поток не продолжит свою работу,
пока не завершится другой поток. Это особенно полезно, когда необходимо собрать результаты работы нескольких потоков или
обеспечить определенный порядок выполнения.

## Что такое ```join()```?

- Метод ```join()```: Это метод класса ```Thread```, который заставляет вызывающий поток приостановиться до тех пор,
  пока поток, на котором вызывается ```join()```, не завершит свое выполнение.

```
public final void join() throws InterruptedException
```

- Перегрузки метода ```join()```:
    - ```join(long millis)```: Ждет определенное количество миллисекунд.
    - ```join(long millis, int nanos)```: Ждет определенное количество миллисекунд и наносекунд.

## Зачем нужен ```join()```?

1. **Синхронизация потоков:**

- **Последовательность выполнения:** Обеспечивает выполнение кода в определенном порядке, несмотря на параллельность
  потоков.
- **Ожидание завершения задач:** Позволяет основному потоку дождаться завершения дочерних потоков перед продолжением
  работы.

2. **Сбор результатов:** Если несколько потоков выполняют вычисления и необходимо собрать их результаты, ```join()```
   гарантирует, что результаты доступны после завершения потоков.
3. **Предотвращеие непредсказуемого поведения:** Без использования ```join()``` главный поток может завершиться раньше,
   чем дочерние потоки, что может привести к неполным операциям или ошибкам.

# Примеры

## [Простой пример](4_1_join.md) использования join()

```java
public class SimpleJoin {
    public static void main(String[] args) {
        Thread thread = new Thread(new Task(), "Рабочий поток");
        thread.start();

        try {
            System.out.println("Главный поток ждет завершения рабочего потока...");
            thread.join();
            System.out.println("Рабочий поток завершен. Продолжение работы главного потока.");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class Task implements Runnable {
    @Override
    public void run() {
        System.out.println("Рабочий поток выполняется...");
        try {
            Thread.sleep(2000); // Симулируем работу
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Рабочий поток завершен.");
    }
}
```

- **Главный поток** (```main```):
    - Запускает новый поток ```thread```.
    - Вызывает ```thread.join()```, чтобы ждать завершения ```thread```.
    - После завершения рабочего потока продолжает свою работу.
- **Рабочий поток** (```Task```):
    - Выполняет некоторую работу (симулируемую ```Thread.sleep(2000)```).
    - По завершении выводит сообщение.

## Пример с тайм-аутом

```java
public class TimeOut {
    public static void main(String[] args) {
        Thread thread = new Thread(new LongTask(), "Долгий поток");
        thread.start();

        try {
            System.out.println("Главный поток ждет не более 1 секунды...");
            thread.join(1000); // Ждем не более 1 секунды
            if (thread.isAlive()) {
                System.out.println("Долгий поток все еще работает после 1 секунды.");
            } else {
                System.out.println("Долгий поток завершен до истечения 1 секунды.");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Главный потокз завершен.");
    }
}

class LongTask implements Runnable {
    @Override
    public void run() {
        System.out.println("Долгий поток выполняется...");
        try {
            Thread.sleep(3000); // Симулируем долгую работу
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Долгий поток завершен.");
    }
}
```

- ```thread.join(1000)```: Главный поток ждет не более 1 секунды.
- **Проверка** ```thread.isAlive()```: После ожидания проверяем, завершился ли поток.
- **Результат:**
    - Если поток завершился до 1 секунды, главный поток продолжает работу.
    - Если нет, главный поток может решить, что делать дальше.

## [Практический пример](code%2FParallelComputationExample.java): Параллельные вычисления и сбор результатов

```java
public class ParallelComputation {
    public static void main(String[] args) {
        List<Thread> threads = new ArrayList<>();
        List<Integer> results = new ArrayList<>();

        // Создаем и запускаем несколько потоков
        for (int i = 0; i < 5; i++) {
            int index = i;
            Thread thread = new Thread(() -> {
                int result = compute(index);
                synchronized (results) {
                    results.add(result);
                }
            });
            threads.add(thread);
            thread.start();
        }

        // Ждем завершения всех потоков
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        // Обрабатываем результаты
        int total = results.stream().mapToInt(Integer::intValue).sum();
        System.out.println("Общий результат: " + total);
    }

    public static int compute(int value) {
        // Симулируем сложное вычисление
        try {
            Thread.sleep(1000 * value);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return value * value;
    }
}
```

- **Создание потоков:** Запускаем 5 потоков, каждый из которых выполняет метод ```compute(int value)```.
- **Сбор результатов:**
    - Результаты вычислений добавляются в общий список ```results```.
    - Используем синхронизацию при добавлении в список, чтобы избежать проблем с конкурентным доступом.
- **Ожидание завершения**: Главный поток ждет завершения всех потоков с помощью ```join()```.
- **Обработка результатов**: После завершения всех потоков суммируем результаты.

# Особенности и предостережния при использовании ```join()```

1. **Блокировка вызывающего потока:** Метод ```join()``` блокирует вызывающий поток до завершения целевого потока или до
   истечения тайм-аута.
2. **Обработка ```InterruptedException```:** Метод ```join()``` может бросать ```InterruptedException```, если
   вызывающий поток был прерван. Следует правильно обрабатывать это исключение.
3. **Возможность дедлока**: Неправильное использование ```join()``` может привести к взаимной блокировке (deadlock),
   если потоки ждут друг друга.
4. **Использование с ```ExecutorService```**: При использовании пулов потоков из ```java.util.concurrent```
   методы ```join()``` не применяются. Вместо этого используются ```Future``` и методы ```get()``` для ожидания
   завершения задач.

# Когда не следует использовать ```join()```

1. **При использовании высокоуровневых API:** Если вы используете ```ExecutorService``` или другие асинхронные
   механизмы, методы ```join()``` не нужны.
2. **В GUI-приложениях:** Блокировка основного (GUI) потока может привести к замораживанию интерфейса. Вместо этого
   используйте асинхронные коллбеки или обработчики событий.
3. **Когда требуется неконкурентное выполнение:** Если задачи могут выполняться независимо и результаты не нужны
   немедленно, использование ```join()``` может быть избыточным.

# Заключение

Метод ```join()``` является простым и эффективным инструментом для управления потоками в Java, позволяя организовывать
их взаимодействие и обеспечивать последовательность выполнения. Он необходим, когда:

- Необходимо дождаться завершения одного или нескольких потоков перед продолжением работы.
- Требуется собрать результаты параллельных вычислений.
- Важно обеспечить определенный порядок выполнения операций в многопоточной среде.

Однако следует использовать ```join()``` с осторожностью, избегая ситуаций, которые могут привести к взаимной блокировке
или снижению производительности из-за ненужной блокировки потоков.
