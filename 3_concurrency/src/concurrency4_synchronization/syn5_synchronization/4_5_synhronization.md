# synchronized

Ключевое слово ```synchronized``` в Java используется для обеспечения **взаимного исключения (mutual exclusion)** и
синхронизации доступа к общим ресурсам в многопоточном программировании. Оно гарантирует, что только один поток может
выполнять синхронизированный блок кода или метод в определенный момент времени, предотвращая тем самым гонки данных (
data races) и обеспечивая целостность данных.

## Зачем нужно ```synchronized```?

- **Предотвращение гонок данных**: Когда несколько потоков одновременно обращаются к общим изменяемым данным, может
  возникнуть ситуация гонки данных, приводящая к некорректным результатам.
- **Обеспечение атомарности операций**: Некоторые операции над данными должны выполняться как неделимые (атомарные) для
  сохранения консистентности состояния объекта.
- **Управление порядком выполнения**: Гарантирует, что определенные участки кода выполняются последовательно, несмотря
  на параллельность потоков.

## Как работает ```synchronized```?

В Java каждый объект имеет **монитор (monitor)** — механизм для контроля доступа к критическим секциям кода. Когда поток
входит в синхронизированный блок или метод, он захватывает монитор объекта. Если монитор уже захвачен другим потоком,
текущий поток блокируется и ждет освобождения монитора.

- **Монитор объекта**: Каждому объекту соответствует один монитор. Например, если используется ```synchronized(this)```,
  монитор захватывается текущим объектом.
- **Монитор класса**: Для синхронизации статических методов используется монитор класса (```Class```-объекта).

## Использование ```synchronized```

### Синхронизация методов

- **Синхронизированные экземплярные методы.** Когда метод объявлен как ```synchronized```, монитор захватывается на
  уровне текущего экземпляра (```this```). Аналогично выделению кода при помощи блока ```synchronized(this)```.

```java
public class Counter {
    private int count = 0;

    // Синхронизированный метод для инкремента
    public synchronized void increment() {
        count++;
    }

    // Синхронизированный метод для получения значения
    public synchronized int getCount() {
        return count;
    }
}
```

---

- **Синхронизированные статические методы:** Для синхронизации на уровне класса используется синхронизированный
  статический метод, который захватывает монитор класса. Аналогично выделению кода при помощи
  блока ```synchronized(class)```.

```java
public class Logger {
    // Синхронизированный статический метод
    public static synchronized void log(String message) {
        System.out.println(message);
    }
}
```

### Синхронизация блоков кода

Иногда требуется синхронизировать только часть метода. В таких случаях используется синхронизированный блок, в котором
явно указывается объект-монитор.

```java
public class BankAccount {
    private int balance = 0;
    private final Object lock = new Object();

    public void deposit(int amount) {
        synchronized (lock) { // Захват монитора объекта lock
            balance += amount;
        }
    }

    public void withdraw(int amount) {
        synchronized (lock) { // Захват монитора объекта lock
            if (balance >= amount) {
                balance -= amount;
            }
        }
    }

    public int getBalance() {
        synchronized (lock) { // Захват монитора объекта lock
            return balance;
        }
    }
}
```

- **Гибкость**: Синхронизируете только необходимые части кода, уменьшая время удержания монитора.
- **Избежание блокировок на уровне всего объекта**: Позволяет использовать разные объекты-мониторы для разных частей
  данных

## Особенности и важные моменты при использовании synchronized

1. **Порядок захвата блокировок:** Важно соблюдать порядок захвата нескольких мониторов, чтобы избежать взаимной
   блокировки потоков.
2. **Монитор по умолчанию:** Каждый объект имеет свой монитор. Синхронизированные статические методы используют монитор
   класса
3. **Производительность:**
    - Избыточная синхронизация может снижать производительность из-за блокировок и контекстных переключений.
    - Минимизируйте область синхронизации до необходимого минимума.
4. **Потокобезопасность:** ```synchronized``` обеспечивает только взаимное исключение, но не всегда достаточно для
   полной потокобезопасности.

## Сравнение ```synchronized``` и ```Lock```

| Особенность                              | `synchronized`                                                            | `Lock` (`ReentrantLock`)                                                                |
|------------------------------------------|---------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|
| **Захват блокировки**                    | Неявный при входе в метод или блок                                        | Явный вызов `lock()`                                                                    |
| **Освобождение блокировки**              | Неявно при выходе из метода или блока                                     | Явный вызов `unlock()`, обычно в блоке `finally`                                        |
| **Обработка исключений**                 | Автоматическое освобождение при выходе из блока                           | Требуется вручную освобождать в блоке `finally`                                         |
| **Проверка состояния блокировки**        | Нет                                                                       | Да, методы `tryLock()`, `isLocked()`                                                    |
| **Возможность прерывания при ожидании**  | Нет                                                                       | Да, метод `lockInterruptibly()`                                                         |
| **Поддержка условных переменных**        | Ограничено использованием `wait()`, `notify()`, `notifyAll()`             | Да, через объекты `Condition`                                                           |
| **Справедливость блокировки (Fairness)** | Нет                                                                       | Может быть настроена при создании `ReentrantLock(true)`                                 |
| **Рекурсивность**                        | Да                                                                        | Да                                                                                      |
| **Производительность**                   | Простота использования, но может быть ниже в условиях высокой конкуренции | Более гибкий и потенциально более производительный в некоторых случаях                  |
| **Гибкость**                             | Ограниченная, все что нужно — синхронизировать метод или блок             | Высокая гибкость: различные методы захвата блокировки, работа с условными переменными   |
| **Простота использования**               | Высокая, меньше кода                                                      | Ниже, требует явного управления блокировкой                                             |
| **Избежание deadlock**                   | Нужно осторожно проектировать                                             | Предоставляет больше инструментов для управления блокировками и предотвращения deadlock |

## Лучшие практики при использовании ```synchronized```

1. **Минимизируйте область синхронизации:** Синхронизируйте только необходимую часть кода, чтобы уменьшить время
   удержания монитора и повысить производительность.
2. **Используйте отдельные объекты-мониторы:** Вместо использования synchronized(this), лучше использовать приватные
   объекты-мониторы для разделения синхронизированных секций.
3. **Избегайте вложенной синхронизации разных мониторов:** Это может привести к дедлокам. Если необходимо
   синхронизировать несколько ресурсов, следуйте строгому порядку их захвата.
4. **Не держите блокировки длительное время:** Избегайте выполнения долгих операций внутри синхронизированных блоков,
   чтобы не блокировать другие потоки.
5. **Используйте ```synchronized``` для защиты инвариантов класса:** Обеспечивайте, чтобы состояние объекта оставалось
   консистентным при изменении из нескольких потоков.

## Заключение

Ключевое слово ```synchronized``` является основным механизмом синхронизации в Java, обеспечивая безопасность при
доступе к общим ресурсам в многопоточной среде. Оно позволяет предотвратить гонки данных и обеспечивает целостность
состояния объектов. Правильное использование ```synchronized``` требует понимания его работы, осторожности при
проектировании синхронизированных блоков и методов, а также соблюдения лучших практик для избежания потенциальных
проблем, таких как дедлоки.

