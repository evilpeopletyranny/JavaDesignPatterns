# MUTEX (Мьютекс)

**Мьютекс** (от англ. mutex — mutual exclusion, взаимное исключение) — это механизм синхронизации в многопоточном программировании, который обеспечивает **эксклюзивный доступ** к общему ресурсу для одного потока в определенный момент времени. Он предотвращает одновременное использование ресурса несколькими потоками, что может привести к некорректному поведению программы или повреждению данных.

## Зачем нужен мьютекс в многопоточном программировании?

- **Предотвращение гонок данных (Data Races)**: Когда несколько потоков одновременно обращаются к общему изменяемому ресурсу без надлежащей синхронизации, может возникнуть ситуация гонки данных, приводящая к непредсказуемым результатам.
- **Обеспечение целостности данных**: Мьютекс гарантирует, что операции над общим ресурсом выполняются атомарно, сохраняя данные в консистентном состоянии.
- **Управление доступом к ресурсам**: Ограничивает доступ к критическим секциям кода, предотвращая одновременное выполнение кода несколькими потоками.

## Мьютекс в Java

В Java мьютексы реализуются через различные механизмы синхронизации:

- **Ключевое слово ```synchronized```**: Предоставляет простой способ синхронизации методов и блоков кода.
- **Классы из пакета ```java.util.concurrent.locks```**: Предоставляют более гибкие и продвинутые механизмы синхронизации, включая интерфейс ```Lock```, который можно рассматривать как реализацию мьютекса.

# Интерфейс Lock как реализация мьютекса

```Lock``` — это интерфейс из пакета ```java.util.concurrent.locks```, который предоставляет возможность более гибкого управления блокировками по сравнению с использованием ключевого слова synchronized. Основной реализацией интерфейса Lock является класс ReentrantLock.

## Почему использовать Lock, а не synchronized?

- **Гибкость в управлении блокировками:** Необязательный порядок разблокировки: С ```Lock``` вы можете разблокировать в любом месте кода, в то время как ```synchronized``` блокировки автоматически снимаются при выходе из блока или метода.
- **Возможность проверки состояния блокировки:** Методы ```tryLock()```, ```isLocked()``` позволяют проверять, доступна ли блокировка, без необходимости блокировать поток.
- **Поддержка условных объектов (```Condition```)**: Позволяют управлять очередями ожидания более гибко по сравнению с использованием методов ```wait()``` и ```notify()```.
- **Высокая производительность:** В некоторых случаях ```ReentrantLock``` может обеспечивать лучшую производительность и масштабируемость.

## Использование ReentrantLock

- ```lock()```: Захватывает блокировку. Если блокировка недоступна, поток будет ждать, пока она не станет доступна.
- ```unlock()```: Освобождает блокировку.
- ```tryLock()```: Пытается захватить блокировку без ожидания. Возвращает ```true```, если блокировка была успешно захвачена.

## Пример использования 

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MutexExample {
    private final Lock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock(); // Захватываем блокировку
        try {
            count++;
        } finally {
            lock.unlock(); // Всегда освобождаем блокировку в блоке finally
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

- **Создание ```ReentrantLock```**: ```private final Lock lock = new ReentrantLock()```; — создаем экземпляр блокировки.
- **Захват и освобождение блокировки**:
  - ```lock.lock()``` — поток захватывает блокировку перед выполнением критической секции.
  - ```lock.unlock()``` — освобождаем блокировку в блоке ```finally```, чтобы гарантировать освобождение даже при возникновении исключений.

```java
public void tryIncrement() {
    if (lock.tryLock()) {
        try {
            count++;
        } finally {
            lock.unlock();
        }
    } else {
        System.out.println("Не удалось захватить блокировку, операция пропущена.");
    }
}
```

- ```tryLock()``` возвращает ```true```, если блокировка была успешно захвачена, иначе ```false```.
- Это позволяет избежать блокировки потока при невозможности захватить блокировку.

## Сравнение ```Lock``` и ```synchronized```

| Особенность                                | `Lock`                                    | `synchronized`                                        |
|--------------------------------------------|-------------------------------------------|-------------------------------------------------------|
| Захват блокировки                          | Явный вызов `lock()`                      | Неявный при входе в синхронизированный блок или метод |
| Освобождение блокировки                    | Явный вызов `unlock()`                    | Неявный при выходе из синхронизированного блока или метода |
| Обработка исключений при блокировке        | Требуется блок `try-finally` для гарантии освобождения блокировки | Автоматическое освобождение блокировки |
| Возможность проверки состояния блокировки  | Да, методы `tryLock()`, `isLocked()`      | Нет                                                   |
| Возможность прерывания при ожидании блокировки | Да, метод `lockInterruptibly()`           | Нет, не поддерживается                                |
| Поддержка условных переменных              | Да, через объекты `Condition`             | Ограничена, с использованием `wait()`, `notify()`, `notifyAll()` |
| Справедливость блокировки (Fairness)       | Может быть настроена при создании `ReentrantLock` | Нет, не поддерживается                                |
| Производительность                         | Может быть выше в условиях высокой конкуренции | Обычно немного ниже из-за ограниченной гибкости        |
| Рекурсивность                              | Да, поддерживается                        | Да, поддерживается                                    |
| Простота использования                     | Требует более внимательного управления блокировками | Прост в использовании, меньше кода                    |

## Когда использовать ```Lock```?

- **Необходима гибкость:** Когда требуется более тонкий контроль над блокировками и управление очередями ожидания.
- **Улучшение производительности:** В высоконагруженных системах, где ```ReentrantLock``` может предоставить преимущества.
- **Необходимость в неблокирующем захвате:** Использование ```tryLock()``` для попытки захватить блокировку без ожидания.
- **Работа с условными переменными:** Использование ```Condition``` для более гибкого управления потоками ожидания.

