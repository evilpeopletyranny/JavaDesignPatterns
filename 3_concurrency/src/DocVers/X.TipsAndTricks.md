#Дополнительный материал
В первую очередь, эта часть описывает интересные и полезные вещи, не вошедшие в основной курс, не упомянуть о которых,
однако, было бы существенным упущением. Как и следует из названия, эта часть не является обязательной к освоению, но
позволит вам заглянуть немного в будущее и посмотреть на более продвинутые техники оптимизации,

###`Thread.onSpinWait()` 
Специальный аналог `Thread.sleep(long x)` для конструкций с активным ожиданием. 
   JVM может оптимизировать активное ожидание, при использовании этой конструкции. 
   
Пример кода с активным ожиданием:
   ```java
      class EventHandler {
            volatile boolean eventNotificationNotReceived;
            void waitForEventAndHandleIt() {
                while ( eventNotificationNotReceived ) {
                    java.lang.Thread.onSpinWait();
                }
                readAndProcessEvent();
            }
            void readAndProcessEvent() {
                // Read event from some source and process it
            }
      }
   ```

###`Thread.yield()` 
по-сути, равносилен `Thread.sleep(0)` - уведомляет JVM о том, что можно отдать всё оставшееся от
текущего кванта времени и вернуть поток в очередь. Если JVM это сделает, какое-то количество инструкций, исполняемых 
после, попадут в один квант времени, что может выступить своего рода оптимизацией. Однако, важно учитывать, что 
выполнение инструкции `Thread.yield()` - не гарантируется, соответственно, 
использовать его можно только в контексте оптимизации, но никак иначе! 
Нужен, в первую очередь для организации своих собственных 
библиотек, реализующих многопоточность.

###`Callable` и `Future`

На самом деле, существуют и другие способы достижения параллельного исполнения кода, однако, задача этого курса — скорее
познакомить с основами, нежели охватить всё многообразие многопоточного мира java. Впрочем, использование такого рода
конструкций в рамках лабораторных работ — не возбраняется, лишь бы использующий понимал, как они работают и для чего 
нужны.
`Callable<V>` - это интерфейс, похожий на `Runnable` однако:
1. Для реализации многопоточности с его использованием необходимо: во-первых переопределить не `run()`, а `call()`.
2. В отличие от `Runnable`, `Callable<V>` использует шаблонный тип `V` и предполагает возвращение значения этого типа
3. Для запуска на исполнение `Runnable` мы использовали `new Thread(Runnable r)` явно. Из-за того, что `Callable` возвращает 
   значения, с ним так уже не получится. Для работы с `Callable<V>` нам потребуется "завернуть" его в `FutureTask<V>` - 
   специальную обёртку, содержащую дополнительную функциональность вроде `V get()` - метода для ожидания и получения 
   результата вычислений, `boolean isDone()` и других.
4. Далее, так как FutureTask реализует интерфейс `Runnable`, для него можно создать отдельный поток и запустить его на
исполнение:
   ```java
   //Реализация интерфейса Callable
    public static class MyCallable implements Callable<String>{
        @Override
        public String call() throws Exception {
            Thread.sleep(Duration.ofSeconds(1).toMillis());
            return "this string has been processed in MyCallable";
        }
        //Демонстрация работы с Callable.
        public static void main(String[] args) throws ExecutionException, InterruptedException {
            //Создаём наш Callable
            MyCallable myCallable = new MyCallable();
            //Заворачиваем его в Future
            FutureTask<String> futureTask = new FutureTask<>(myCallable);
            //создаём для Future новый поток и запускаем его на исполнение
            new Thread(futureTask).start();
            //Пишем что-то в консоль и проверяем, исполнился ли наш Future
            System.out.println("some print in main");
            System.out.println("is future completed: "+futureTask.isDone());
            
            //Ожидаем завершения выполнения нашего Future и выводим результат.
            System.out.println(futureTask.get());
        }
    }
   ```
   
[Пример использования Callable](creation/MoreConvenientCreationMethods.java)

###Lambda-выражения и функциональные интерфейсы.
Лямбда-выражения не являются частью курса ШППО, однако представляют собой простой в освоении, красивый и достаточно 
удобный инструмент в контексте многопоточности java. Заострять внимание на особенностях реализации в java мы не будем, и
вместо этого посмотрим на их использование в коде.

В общем виде лямбда-выражения в java выглядят следующим образом:
- `param -> expression`, в случае, если используемая функция принимает 1 параметр - `param` и возвращает значение, 
вычисляемое как `expression`, например, `x->x*x`
- `(param1, param2)->expression`, если параметра 2 и больше, например, `(x1, x2)->x1*x2`
- `()->expression`, если лямбда-выражение не принимает ни одного параметра, например, 
  ```java
  ()->{ 
    Scanner scanner = new Scanner(System.in);
    return scanner.nextInt();
  };
  ```
Как видно из последнего примера, если expression требует нескольких операций, его можно заключить в `{}`, 
причём результат в таком случае потребуется возвращать при помощи `return`.

Поскольку java - объектно-ориентированный язык, лямбда-выражения являются объектами, но какого типа?
Ненадолго оставим этот вопрос и вернёмся к нему чуть позже с другой стороны — со стороны функциональных интерфейсов.

В общем-то с функциональными интерфейсами всё просто. Это интерфейсы с аннотацией `@FunctionalInterface` и единственным
методом.
Например, как-то так.
```java
@FunctionalInterface
public interface MyFunctionalInterface{
    boolean isEverythingOk();
}
```
И для реализации функционального интерфейса мы можем поступить, как и с обычным интерфейсом: создать класс, 
переопределить метод и пользоваться им.
```java
public class Pessimist implements MyFunctionalInterface{
    @Override
    boolean isEverythingOk(){ return false; }
}
```
Но нужен он для другого. Функциональные интерфейсы можно создавать, используя лямбда-выражения!
```java
public class Main{
    public static void main(String[] args) {
        MyFunctionalInterface optimist = ()->true;
        //При использовании такого рода конструкций, 
        //лямбда выражение вызывается по имени единственного метода функционального интерфейса.
        System.out.println(optimist.isEverythingOk());
    }
}
```
Возвращаясь к типу лямбда-выражения, как видно из примера выше, его тип будет соответствовать функциональному интерфейсу,
описывающему лямбда-выражение. Если такого интерфейса не описано, записать лямбда-выражение в переменную или использовать 
его попросту не получится.

И вот в это месте, может возникнуть закономерный вопрос. Зачем-же нам лямбда-выражения и какое они вообще имеют 
отношение к многопоточности?

А дело всё в том, что `Callable<V>`, ровно, как и `Runnable` - являются функциональными интерфейсами. 
В частности, это значит, что для простых небольших задач, выполняемых параллельно можно пользоваться менее громоздким 
форматом описания:

```java
public class Main {
    public static void main(String[] args) {
        Callable<String> someStringTask = () -> "Some callable string";
        Future<String> someFutureString = new FutureTask<>(someStringTask);
        System.out.println(someFutureString.get());
        //более того, можно передавать лямбду напрямую!
        Future<String> someOtherFutureString = new FutureTask<>(()->"String from directly passed lambda!");
        System.out.println(someOtherFutureString.get());
    }
}
```
Такой-же фокус можно проделывать и с `Runnable`, отличаться он будет только тем, что лямбда-выражение будет передаваться
во вновь создаваемый поток:
```java
public class Main {
    public static void main(String[] args) {
        Runnable r = ()-> System.out.println("Parallelism forever!");
        new Thread(r).start();
        //или напрямую
        new Thread(()->System.out.println("Direct lambdas are cool!"));
    }
}
```
[Демонстрация лямбда-выражений и функциональных интерфейсов](creation/LambdaDemo.java)

###Reference-типы и `volatile`
Как уже было сказано, `volatile` запрещает потокам кешировать значения переменных локально в памяти потока, однако, как
это будет работать со ссылочными типами? 

Если коротко, то логика работы остаётся прежней и содержимое переменной, 
объявленной как `volatile` запрещается копировать в локальную память. Но что содержит ссылочная переменная?

Довольно логично, ссылочная переменная содержит ссылку. То есть, когда мы делаем ссылочную переменную volatile, мы
гарантируем, что содержимое переменной, то есть **сама ссылка на объект и только она** не будет кешироваться. Все данные 
объекта кешироваться при этом будут, если они в свою очередь не объявлены как `volatile`.

<todo example/>
