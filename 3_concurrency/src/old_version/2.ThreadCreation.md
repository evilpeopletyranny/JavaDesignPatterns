<h1 align="center">
    Создание потоков
</h1>

*Поток* — единица исполнения кода. *Основной поток программы* содержит точку входа в программу функцию `main()`. Далее
обусловимся, что

- `main` - основной поток (без скобок).
- ` main() ` - функция main, точка входа в программу.

Очевидно, что main создаётся при запуске приложения, а все прочие потоки должны создаваться где-то
позже. В рамках данной работы будут рассмотрены **два базовых способа создания потоков**:

1. Наследование от класса `Thread` и переопределить его метод `void run()`.
2. Реализация интерфейса `Runnable` и переопределить его метод `void run()`.

Способы во многом похожи, но не одинаковы.

Если обратить внимание то `Thread`, тоже реализует интерфейс `Runnable`.
Разница состоит в том, что `Thread` - представляет собой новый поток, в то время как `Runnable` - представляет собой "
задачу" для исполнения в потоке. Чтобы запустить исполнение чего бы то ни было параллельно `main` необходимо так или
иначе подготовить объект, способный выполняться параллельно, как было описано выше.

<h4 align="center">
    Наследованием от класса Thread
</h4>

```java
class MyThread extends Thread {
    int n;

    public MyThread(int n) {
        this.n = n;
    }

    @Override
    public void run() {
        System.out.println(n);
    }
}
```

<h4 align="center">
    Реализация интерфейса Runnable
</h4>

```java
class MyRunnable implements Runnable {
    int n;

    public MyRunnable(int n) {
        this.n = n;
    }

    @Override
    public void run() {
        System.out.println(n);
    }
}
```

<h4 align="center">
    Запуск потоков
</h4>

```java
    public static void main(String[] args) {

    //Класс, наследующий Thread не нуждается в дополнительном потоке.
    MyThread myThread = new MyThread(1);

    //Поскольку интерфейс Runnable представляет собой "задачку для исполнения",
    //то для её запуска требуется дополнительный поток.
    MyRunnable myRunnable = new MyRunnable(2);
    Thread threadForRunnable = new Thread(myRunnable);

    //Вне зависимости от используемого метода создания, для исполнения поток необходимо запустить
    //Запуск потока произвдиться при помощи метода start()
    myThread.start();
    threadForRunnable.start();
}
```

[Файл с кодом](creation/ThreadCreation.java)

**Внимание!!!** Переопределен метод `run()`, а вызывается метод `start()`. При вызове метода `run()`,
он запустится на исполнение в потоке `main`

<h3 align="center">
    Советы по использованию
</h3>

- **Наследование от `Thread`** целесообразно применять когда необходимо дополнить функционал `Thread`.
- **Реализацию интерфейса `Runnable`** целесообразно применять когда необходимо параллеьно запустить задачу, не менея
  поведение `Thread` и механизм многопоточности.

<h3 align="center">
    Советы по использованию
</h3>

На самом деле, конечно, мир java-многопоточности одними лишь `Thread` и `Runnable` - не ограничивается.

[Здесь](X.TipsAndTricks.md#callable--future) можно найти информацию о `Callable` - альтернативе `Runnable`,
если вычисления должны возвращать значение.

[Здесь](X.TipsAndTricks.md#lambda----) описаны более продвинутые и современные способы создания `Runnable` и `Callable`

<todo Executors/>

###Потоки java.util.concurrent.Thread и потоки операционной системы.
Можно подумать, что при создании потока (`new Thread()`) мы заставляем операционную систему создать для нас поток,
отображением которого
в программе и станет вновь созданный `Thread`. На самом деле, это не так.

Дело в том, что физически создаваемыми и выделяемыми системой потоками управляет JVM. Связано это, в первую очередь
с тем, что создание потока ОС — довольно "дорогая" операция.
Чаще всего это не имеет для нас большого значения, но это стоит иметь в виду,
если вы решите реализовывать свои многопоточные библиотеки.

###Interruptions
С завершением потока стандартным способом всё понятно. Но что, если мы хотим завершить поток некоторым внешним способом?
Сначала был метод, останавливающий исполнение потока, но позже было решено, что обрабатывать ситуацию остановки потока —
должен сам поток. Так появился метод `interrupt()`. Воспринимать это можно как просьбу потоку "пожалуйста остановись"
гарантии, что он остановится — нет. Если поток находится в состоянии ожидания(
вызван `join()`, `sleep()`, `wait()`, ...),
будет брошен InterruptedException и если он не будет обработан — поток прекратит выполнение. Если во время `interrupt()`
поток находится в состоянии `Running`, никакого исключения брошено не будет. Однако будет установлен флаг isInterrupted.
Проверить его можно 2 способами: статическим методом
`Thread.interrupted()`, который считает эту переменную и выставит её в `false` или методом `isInterrupted()`, который
считает переменную, не изменяя её значение. Это можно использовать, чтобы останавливать потоки с бесконечными циклами,
но главное применение этого знания в рамках лабораторных по многопоточности - в том, чтобы не бояться конструкций
try/catch вокруг `Thread.sleep()` и подобных методов.

```java
    try{
        Thread.sleep(someTime);
    }catch(
InterruptedException e){
        throw new

RuntimeException(e);
    }
```

В следующей [части](3.Syncronyzation.md) будут рассмотрены механизмы синхронизации потоков.

