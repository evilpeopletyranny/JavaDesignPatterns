<h1 align="center">
    Механизмы синхронизации
</h1>

### Когда синхронизация не нужна
Представим себе ситуацию, когда все операции, производимые нами в разных потоках — независимые. Например, если мы просто
выводим в консоль различную информацию, не зависящую от действий других потоков.
Для краткости в примерах будут использованы более короткие формы создания заданий для потоков, о которых можно почитать 
[здесь](X.TipsAndTricks.md#lambda----), но если коротко, эти потоки — просто выводят номер итерации, на которой их создали.

[Файл с примером](synchronization/NoRace.java)
```java
public class NoRace {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {
            final int j = i;
            new Thread(()-> System.out.println(j)).start();
        }
    }
}
```
При запуске наблюдаем: действительно, все числа выводятся, но в порядке, отличном от того, в котором создаются
потоки. В данном случае, по условию, нам это не важно, но согласитесь, эффект интересный.

### Базовая синхронизация: `join()`
Когда мы запускаем поток на исполнение, мы будто-бы расщепляем текущую нить исполнения на 2,
в каждой из которых исполняется свой участок кода. `join()` - по сути является способом слияния выбранного
потока с тем, из которого вызывается `join()`. Поток, из которого вызывается `join()` остановит текущий поток, пока тот, 
у которого он вызван не закончит свою работу.
[Пример](synchronization/JoinDemo.java)

А что, если мы хотим получить многопоточный вывод циферок как в первом примере, но в порядке их следования?
Что-ж, пример придётся чуть усложнить, но принципиально ничего не изменится.
Выглядеть это будет приблизительно [так](synchronization/NoReason.java) и на самом деле, в этому случае 
теряется смысл многопоточности, так как по-сути потоки будут исполняться последовательно, но использование
`join()` может иметь
смысл в более сложных случаях.

### Потоки и данные - `volatile`
Вообще, тема того, что включает в себя и с чем связан объект потока — большая и сложная и далеко не всё из неё касается
курса ШППО, поэтому большая её часть останется не охваченной. И всё-же, есть как минимум один аспект, который неизбежно 
будет нас касаться и это — память разделяемая потоками. Дело в чём. Потоки хранят свои копии переменных, 
с которыми работают. Нужно это, как и любое кеширование — для быстродействия, но есть и побочные эффекты.
И для того, чтобы их ощутить, попробуйте предположить, какое число выведет этот 
[пример](synchronization/Race.java) после выполнения:
```java
public class Race {
    //Пусть будет у нас некоторая разделяемая переменная
    static int counter = 0;
    //статически метод, добавляющий к нашей переменной 10000 раз по единице в цикле.
    public static void cyclicAdd(){
        for (int j = 0; j < 10000; j++) {
            counter++;
        }
    }
    public static void main(String[] args) throws InterruptedException {
        //Вектор с потоками
        Vector<Thread> threads = new Vector<>();
        //Создаём 10 потоков, каждый из которых вызывает метод cyclicAdd()
        for (int i = 0; i < 10; i++)
            threads.add(new Thread(Race::cyclicAdd));
        //запускаем все потоки
        for (var t:threads) t.start();
        //ждём, пока все потоки исполнятся
        for (var t:threads) t.join();
        //выводим, то, что оказалось в нашей переменной
        System.out.println(counter);
    }
}
```
Если вы ответили 100 000, то нет. Результат будет зависеть от того, какой поток в какой момент кешировал себе значение 
переменной `counter` и на самом деле кое-от чего ещё, но об этом — чуть позже. Кеширование потоками можно отключить,
если перед переменной поставить ключевое слово `volatile`.
```java
volatile static int counter = 0;
```
[Поставили](synchronization/NotFixedRace.java).
Перезапустили. Стало лучше, но не до конца. А связано это с тем, что операция `counter++` происходит, за 3 шага:
1. Копирование значения из памяти в регистр процессора (длинная, дорогая операция, на время которой поток с 
высокой вероятностью будет вытеснен)
2. Увеличение значения в регистре процессора на 1 (быстрая операция в 1 такт процессора)
3. Копирование значения из регистра обратно в память(снова длинная, дорогая операция)

Вот и получается, что несколько потоков могут скопировать, скажем, одно и то-же значение, прибавить к нему 1, после чего
перезаписать значение переменной несколько раз подряд. Причём в зависимости от порядка, в котором потоки
будут вытесняться и получать кванты времени, результат выполнения программы будет различаться.

Отдельная история про [`volatile` и cсылочные типы](X.TipsAndTricks.md#reference---volatile), с которыми всё не так очевидно, как
может показаться на первый взгляд.

###Понятия гонки, разделяемого ресурса и критической секции
Итак, непредсказуемое поведение, зависящее от порядка исполнения частей кода называется 
**_состоянием гонки_**(Race condition)

С гонкой связано 2 других понятия.

**_Разделяемый ресурс_** - это данные, доступ к которым имеют одновременно несколько потоков. 

**_Критическая секция_** - это участок кода, в рамках которого поток получает **эксклюзивный** доступ к разделяемому 
ресурсу.

В принципе, само по себе наличие доступных нескольким потокам данных не обрекает нас на гонки. Например, если 
разделяемые данные не изменяются в процессе работы, вне зависимости от того, в каком порядке потоки будут эти конкретные
данные использовать.

В нашем [примере](synchronization/NotFixedRace.java), очевидно, разделяемым ресурсом является переменная
`counter`, а в критическую секцию должна быть заключена операция `counter++`

###Атомарные переменные
Наверное, наиболее простой и понятный способ борьбы с гонками. В чём смысл. Раз всё проблема сводится к тому, что 
операция `counter++` может быть выполнена в несколько приёмов, давайте сделаем так, чтобы она не могла быть прервана 
посередине! Чтобы добиться этого в java, нужно использовать специальный вид переменных — атомарные переменные. Атомарная
переменная гарантирует, что она не позволит считать её значение ни одному потоку, до того, как завершится текущая 
операция над ней. И не позволяет менять себя более чем одному потоку одновременно. Таким образом получаем

[Решение с использованием атомарной переменной](synchronization/AtomicRaceSolution.java)
```java
    //Теперь используем атомарную переменную
    volatile static AtomicInteger counter = new AtomicInteger(0);
    //статически метод, добавляющий к нашей переменной 10000 раз по единице в цикле.
    public static void cyclicAdd(){
        for (int j = 0; j < 10000; j++)
            counter.incrementAndGet();
    }
    //весь остальной код остаётся прежним.
```
Как видно, всё работает корректно и результат совпадает с ожидаемым.
Но работает такой способ, к сожалению, только в тех случаях, когда критической секцией является одна операция, которую
поддерживают atomic-переменные.

###Мьютекс
Мьютекс, MUTEX = MUTual EXclusion, что дословно переводится как "взаимное исключение" - именно эту функциональность и 
предоставляет. То есть, позволя организовать критическую секцию.
Мьютекс можно "захватить" `lock()`, "попробовать захватить" `tryLock()`, и "освободить" `unlock()`.
Смысл трёх этих операций в следующем:
1. `lock()` - Если мьютекс свободен, поток его захватит и продолжив выполнение, войдёт в критическую секцию.
 Если мьютекс захвачен, вместо захвата мьютекса произойдёт блокирование потока на операции `lock()` и пока мьютекс не 
   будет освобождён, поток будет ожидать. Как только мьютекс освобождён, один из потоков, заблокированных на нём
   захватит мьютекс и войдёт в критическую секцию.
   
2. `unlock()`, соответственно, освобождает мьютекс.
3. `tryLock()` совершает попытку блокировки на мьютексе и возвращает `true` в случае успеха и `false` в случае неудачи.
В отличие от `lock()`, вне зависимости от результата выполнения, `tryLock()` **НЕ** блокирует дальнейшее выполнение кода.
   `tryLock()` применяется в случаях, когда разделяемых ресурсов несколько и для выполнения критической секции необходим 
   захват их всех.
   
Важно, что все операции, выполняемые над мьютексом — потокобезопасные.

Часто, мьютекс содержит и другую функциональность однако описанного — вполне достаточно для создания 
критической секции любой сложности.

Итак, каким образом организовать доступ к простейшей критической секции с один разделяемым ресурсом?
1. Выполнить `lock()` перед критической секцией.
2. Выполнить `unlock()` после неё.

Довольно просто.

В java механизм, способный выполнять роль мьютекса в явном виде описывается интерфейсом `Lock`
Вообще, классов и интерфейсов, реализующих `Lock` - много и каждый из них реализует какую-то дополнительную 
функциональность, но здесь речь идёт о базовых конструкциях.

И вот, применяя все полученные знания, имеем [следующее](synchronization/LockRaceSolution.java):

```java
public class LockRaceSolution {
    //Пусть будет у нас некоторая разделяемая переменная
    static volatile int counter = 0;
    //Создадим также наш аналог мьютекса
    static Lock lock = new ReentrantLock();
    //статически метод, добавляющий к нашей переменной 10000 раз по единице в цикле.
    public static void cyclicAdd(){
        lock.lock();
        for (int j = 0; j < 10000; j++)
            counter++;
        lock.unlock();
    }

    public static void main(String[] args) throws InterruptedException {
        //Вектор с потоками
        Vector<Thread> threads = new Vector<>();
        //Создаём 10 потоков, каждый из которых вызывает метод cyclicAdd()
        for (int i = 0; i < 10; i++)
            threads.add(new Thread(LockRaceSolution::cyclicAdd));
        //запускаем все потоки
        for (var t:threads) t.start();
        //ждём, пока все потоки исполнятся
        for (var t:threads) t.join();
        //выводим, то, что оказалось в нашей переменной
        System.out.println(counter);
    }
}
```
Кстати, переменную `lock` в этом примере — не требуется делать `volatile`, поскольку Lock - инициализируется до
инициализации потоков. А поскольку `lock` - объект, то как и все объекты — 
является ссылочным типом, а значит для него работают [эти](X.TipsAndTricks.md#reference---volatile) правила
### Потокобезопасность — это дорого!
Любые потокобезопасные операции — довольно дорогие, поэтому количество их применений должно быть разумным. Если 
переписать этот пример таким образом, чтобы критическая секция окружала только операцию `counter++`, и поднять число 
итераций, время выполнения станет заметно без специальных измерений.
```java
    public static void cyclicAdd(){
        for (int j = 0; j < 10000000; j++) {
            lock.lock();
            counter++;
            lock.unlock();
        }
    }
```
Здесь может показаться, что 10000000 операций — сами по себе довольно долгие, но нет. Следующий код выполняется быстрее, 
даже несмотря на то, что по-сути, если вдуматься, одновременно будет исполняться только один поток, а код выше — вроде 
как более параллельный.
```java
    public static void cyclicAdd(){
        lock.lock();
        for (int j = 0; j < 10000000; j++) {
            counter++;
        }
        lock.unlock();
    }
```
###Нерадивые программисты
Вся проблема мьютекса, да и на самом деле, не только его - в том, что потоку никто не запрещает его игнорировать. 

Аналогия следующая: представьте, что критическая секция — это комната, в которой **должно** находиться не более одного 
человека. Мьютекс — это запирающийся изнутри замок на двери комнаты. Каждый, кто попробует открыть дверь — будет им 
заблокирован, пока находящийся внутри человек не выйдет. Также, за ручку двери можно подёргать и понять, закрыта она или
нет — это соответственно аналоги `lock()` и `tryLock()`. Потоки в нашей аналогии — это соответственно люди... 

Но вот незадача. 

Стен у нашей комнаты нет. 

И в принципе, любой может зайти в нашу комнату-критическую секцию, когда захочет и совсем не 
обязан связываться с замком. Таким образом, возвращаясь от нашей аналогии к потокам и мьютексам, именно программист 
должен следить за тем, чтобы все потоки, работающие с мьютексами, работали с ними корректно.

Именно по-этому мьютекс, как низкоуровневый механизм синхронизации имеет смысл применять **только** тогда, когда вы 
реализовываете некоторый низкоуровневый многопоточный алгоритм, а в иных случаях использовать более высокоуровневые 
конструкции.

###Семафор
В общем-то, семафор — это обобщение мьютекса. Если у мьютекса состояния 2: свободен и занят(`0` и `1`, `true` и `false`)
то у семафора их может быть больше. Если мьютекс содержит переменную типа `boolean`, то семафор — переменную типа `int`
Другими словами, всё остаётся по прежнему, только вместо `lock()` у нас теперь `acquire()`, 
вместо `unlock()` - `release()` а вместо `tryLock()` - `tryAcquire()`. Когда вызывается `acquire()`, содержащаяся в 
семафоре переменная убавляется на 1, `release()` - соответственно, увеличивает это значение на 1. Если переменная 
становится равной или меньшей 0, `acquire()` блокирует поток до тех пор, пока число не станет > 0.

В качестве демонстрации, взглянем на [решение](synchronization/SemaphorePhilosophersSolution.java) следующей задачи:
Это одна из вариаций на тему задачи об обедающих философах. Звучит она так:
Есть стол, за которым могут сидеть не более 2-х человек.
Есть некоторое количество философов. Нужно организовать доступ к столу таким образом, чтобы все философы по
очереди садились за стол и обедали.

В принципе, задачу можно решить и при помощи мьютекса, но такое решение, по-сути просто будет эмулировать семафор.

Все методы семафора могут принимать в качестве 
аргумента число и убавлять (в случае `acquire()`) или прибавлять (в случае `release()`) это число к содержащейся в 
семафоре переменной. При этом, нельзя забрать из семафора больше, чем там есть, при попытке это сделать поток 
заблокируется до тех пор, пока в переменная в семафоре не достигнет необходимого значения. 
Всё это позволяет куда более гибко манипулировать потоками.

[Например вот так](synchronization/SemaphoreAcquireFlex.java)

Впрочем, используется семафор — редко. Более того, как и в случае с мьютексом, он не обеспечивает безопасность 
"из коробки", поэтому какой-либо смысл приобретает только в контексте разработки каких-то собственных алгоритмов 
многопоточности или потокобезопасных структур.

###Монитор
В java, у каждого объекта есть свой собственный мьютекс. Его нельзя получить и использовать напрямую и нужен он для 
реализации механизма, который называется **монитор**. Как он работает? - очень просто. До выделенного участка кода он
захватывает мьютекс связанного с ним объекта, а после этого участка — освобождает его мьютекс. В java такой участок кода
обозначается ключевым словом `synchronized` 

Выглядит синхронизация на мьютексе некоторого объекта obj [так](synchronization/MonitorUsageDemo.java).
```
synchronized (obj){
    criticalOeration();
}
```
Ключевое слово `synchronized` можно ставить перед блоком кода в `{}` или перед методом. В этом случае монитор 
будет распростроняться на весь метод целиком, а мьютекс для синхронизации будет взят из объекта, метод которого 
вызывается.
```java
public class SomeObject{
    public synchronized void  doSomeCriticalAction(){
        //какой-то код, требующий эксклюзивности.
    }
    public synchronized void  doSomeOtherCriticalAction(){
        //какой-то код, требующий эксклюзивности.
        
        //Если существует хотя-бы один поток, использующий один из методов, 
        //ни один другой поток не сможет зайти в них,
        //Пока первый не закончит
    }
}
```
Соответственно, при помощи мониторов наша задача решается как-то [так](synchronization/MonitorRaceSolution.java)
```java
    //статически метод, добавляющий к нашей переменной 10000 раз по единице в цикле.
    public static synchronized void cyclicAdd(){
        for (int j = 0; j < 10000; j++)
            counter++;
    }
```

###Deadlock
Допустим, критические секции мы организовать умеем, но проблемы на этом не заканчиваются. Рассмотрим следующую задачу.

Вы с другом сидите на кухне и завтракаете хлебом с вареньем. На двоих у вас одна банка с вареньем и 
одна буханка хлеба. Очевидно, чтобы намазать варенье на хлеб, вам нужно 

1. Взять буханку хлеба.
2. Отрезать кусок хлеба от буханки.
3. Взять банку с вареньем и намазать вареньем хлеб.

Вы никак не можете взять банку и хлеб одновременно.


        //хлеб
        Lock bread = new ReentrantLock();
        //варенье
        Lock jam = new ReentrantLock();

Представьте себе ситуацию, в которой вы взяли буханку хлеба, а ваш друг — банку варенья. 
```
        //вы
        Thread you = new Thread(()-> {
                System.out.println("you have started eating attempt");
                bread.lock();
                try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); }
                jam.lock();
                System.out.println("You are eating bread with jam");
                jam.unlock();
                bread.unlock();
        });
        //ваш друг
        Thread yourFriend = new Thread(()-> {
                System.out.println("your friend has started eating attempt");
                jam.lock();
                try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); }
                bread.lock();
                System.out.println("YourFriend is eating bread with jam");
                bread.unlock();
                jam.unlock();
        });
        //запускаем
        you.start();
        yourFriend.start();
        //ждём пока все закончат
        you.join();
        yourFriend.join();
        //Говорим, что всё хорошо.
        System.out.println("if this message appeared, you and your friend have done eating");
        //Но здесь мы скорее всего не окажемся.
```
Каждый из вас пытается взять 
второй ресурс, но не может, так как ресурс уже захвачен и блокируется на нём. Таким образом, ваша трапеза не 
продвигается вперёд. Произошедшая ситуация и называется **deadlock**. 


Говоря более формально, **deadlock** - это 
взаимная блокировка потоков на разделяемых ресурсах таким образом, что ни один из её участников не может продолжать 
выполнение. 

Также, deadlock - это частный случай гонки. Возможна ситуация, при которой сначала вы взяли хлеб и варенье, намазали, 
освободили ресурсы и пока вы едите, ваш друг успел сделать то же самое. В таком случае, вы не заблокируетесь, 
однако рано или поздно, если не принято никаких мер, deadlock может произойти. 

###Livelock
Она-же — динамическая блокировка. Состояние, в котором, формально, система продолжает работать, но циклически блокирует
и разблокирует одни и те-же ресурсы.

Наверное, каждый попадал в ситуацию, когда идя навстречу человеку вы с ним одновременно смещались в одну и ту-же сторону,
пытаясь уступить дорогу, но в итоге в течение нескольких секунд, пытались обойти друг друга. Это и был **livelock**

###Обнаружение взаимных блокировок
Если коротко.

Поиск взаимных блокировок осуществляется путём построения и анализа графа ожидания. 
В графе ожидания узлами отмечаются потоки и объекты. 

Блокировки отмечаются рёбрами, направленными от узла, соответствующего захваченному объекту, к узлу, соответствующему 
захватившему его потоку. 

Ожидания отмечаются рёбрами, направленными от узла, соответствующего ожидающему потоку, к узлу, соответствующему 
ожидаемому объекту.

Цикл в графе ожидания соответствует взаимной блокировке.

Практически об устранении взаимных блокировок надо заботиться ещё на этапе проектирования системы — это единственный 
более или менее надежный способ борьбы с ними.

###Предотвращение взаимных блокировок
Классический способ борьбы с проблемой — разработка иерархии блокировок: между блокировками устанавливается отношение 
сравнения и вводится правило о запрете захвата «большей» блокировки в состоянии, когда уже захвачена «меньшая». 
Таким образом, если процессу нужно несколько блокировок, ему нужно всегда начинать с самой «большой» — предварительно 
освободив все захваченные «меньшие», если такие есть — и затем в нисходящем порядке.

В для разрешения [нашего](synchronization/Deadlock.java) deadlock'а достаточно блокировать ресурсы в одном порядке 
обоими потоками. В результате, получаем [такой](synchronization/DeadlockSolution.java) код:
```java
        //вы
        Thread you = new Thread(()-> {
            System.out.println("you have started eating attempt");
            jam.lock();
            try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); }
            bread.lock();
            System.out.println("You are eating bread with jam");
            bread.unlock();
            jam.unlock();
        });
        //ваш друг
        Thread yourFriend = new Thread(()-> {
            System.out.println("your friend has started eating attempt");
            jam.lock();
            try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); }
            bread.lock();
            System.out.println("YourFriend is eating bread with jam");
            bread.unlock();
            jam.unlock();
        });
```
Можно выполнять этот код любое количество раз, из-зи того, что одна критическая секция "накрывается" другой, войти
в неё, не войдя при этом в первую — невозможно.

###Daemon и user потоки.

Потоки бывают 2 типов: потоки пользователей(user threads) и демоны(deamon threads). 
Предположим, что main закончил выполнять последнюю описанную в нём операцию, но при этом, остались незавершенными потоки
исполняемые параллельно. Что-то произойдёт дальше? Пока в системе остаются пользовательские потери, исполнение будет 
продолжаться, но как только они закончатся, исполнение всех потекла будет остановлено и JVM завершит свою работу. 
Таким образом, deamon-потоки дорожная использоваться исключительно для обслуживания нужд потоков пользовательских. 
Из этого напрямую следует, что daemon-потоки не следует использовать для операций ввода и вывода, например.

По-умолчанию, потоки создаются как user thread, для того чтобы сделать их демонами, нужно вызвать у них
`setDaemon(true)`

Взглянуть на это можно [здесь](synchronization/DaemonsDemo.java)

<todo thread_state/>

###Взаимодействия потоков: `wait()`,` notify()`
Иногда, необходимо не только обеспечить эксклюзивность доступа к секции, но и уведомлять потоки о действиях друг друга.
Предположим, мы хотим реализовать свой объект, эмулирующий мьютекс, доступными нам методами синхронизации.
Реализовывать интерфейс `java.concurrency.locks.Lock` мы не будем, потому что он устроен несколько сложнее. 
Реализовывать `tryLock()` мы также не станем. Остаётся 2 метода: `lock()` и `unlock()`. Очевидно, что оба метода должны
быть `synchronyzed`. Но что, по-сути, должны делать метолы `lock()` и `unlock()` с точки зрения входящих в них потоков?
`lock()`, очевидно, должен пропустить дальше первый вошедший в него поток и заблокировать все остальные. 
В свою очередь, `unlock()` должен разблокировать один из потоков блокированных в `lock()`. Для этого нам потребуется 
использовать методы `wait()` и `notify()`.`wait()` - позволяет усыпить поток, в котором он исполняется. При этом,
поток связывается с монитором объекта, чей `wait()` был вызван. Если после этого вызвать у монитора `notify()`, 
он разбудит один из спящих на его методе `wait()` потоков и тот продолжит исполнение. Также есть метод `notifyAll()`, 
он соответственно будит все спящие на мониторе потоки. При этом важно, что секция `synchronyzed` - остаётся критической,
то есть, в один момент времени, в ней всё равно исполняется только один поток. Эти методы должны вызываться только и 
исключительно в синхронизованном контексте!
Итак.
- `wait()` - усыпляет текущий поток на мониторе.
- `notify()` - будит один из потоков, спящих на мониторе.
- `notifyAll()` - будит все потоки, спящие на мониторе.

Зная это, реализуем [наш упрощённый](synchronization/SimpleLockDemo.java) мьютекс.
```java
public class SimpleLock {
    //Захвачен ли мьютекс прямо сейчас
    volatile boolean isLocked = false;

    //должен блокировать все входящие потоки, кроме одного.
    synchronized void lock() {
        //Если мьютекс захачен - ждём.
        while (isLocked) {
            try {
                wait();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        //Соответственно, если мьютекс освобождается - захватываем
        isLocked = true;
    }

    //Должен высвобождать один поток.
    synchronized void unlock(){
        //снимаем захват мьютекса
        isLocked = false;
        //будим один поток из числа ожидающих.
        notify();
    }
}
```

Проверим, что наш мьютекс работает как надо: применим его к нашему [примеру](synchronization/OwnLockRaceSolution.java) со счётчиком


###Как избежать проблем при проектировании многопоточности?
Подведём итоги.
1. В критической секции не могут находиться 2 потока одновременно. (То есть, нужен механизм, который это обеспечит и 
   все потоки, входящие в критическую секцию, должны им пользоваться)
2. При проектировании нельзя делать предположения о скорости выполнения кода или количестве процессоров. (То есть, 
   никаких "поставлю `sleep(1000)` - всё точно успеет выполниться...")
3. Поток вне критической секции не должен блокировать другие потоки.
4. Невозможна ситуация, когда поток вечно ждёт попадания в критическую секцию.


























