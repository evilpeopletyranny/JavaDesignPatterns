# Deadlock и Livelock

В многопоточном программировании **Deadlock** и **Livelock** являются двумя типами состояний блокировки, которые могут
привести к некорректной работе или зависанию приложения. Понимание этих состояний и способов их предотвращения является
ключевым для разработки надёжных и эффективных многопоточных приложений.

# Deadlock

**Deadlock** — это состояние, при котором два или более потоков навсегда блокируют друг друга, ожидая освобождения
ресурсов, которые находятся под контролем других потоков. В результате ни один из потоков не может продолжить
выполнение, что приводит к зависанию приложения.

## Причины возникновения Deadlock

Deadlock возникает, когда одновременно выполняются четыре условия, известные как **условия Coffman**:

1. **Взаимное исключение (Mutual Exclusion)**: Ресурс может быть захвачен только одним потоком за раз.
2. **Удержание и ожидание (Hold and Wait)**: Поток удерживает по крайней мере один ресурс и ожидает захвата
   дополнительных ресурсов, удерживаемых другими потоками.
3. **Отсутствие принудительного освобождения (No Preemption)**: Ресурсы не могут быть принудительно освобождены; они
   могут быть освобождены только потоком, который их захватил.
4. **Циклическое ожидание (Circular Wait)**: Существует цикл из двух или более потоков, каждый из которых ожидает
   ресурса, удерживаемого следующим потоком в цикле.

## Пример Deadlock-а

Рассмотрим ситуацию, где два потока пытаются получить доступ к двум ресурсам в разном порядке, что приводит к взаимной
блокировке.

```java
public class Main {
    public static void main(String[] args) {
        final Object resourceA = "Resource A";
        final Object resourceB = "Resource B";

        // Поток 1 пытается захватить ресурс A, затем ресурс B
        Thread thread1 = new Thread(() -> {
            synchronized (resourceA) {
                System.out.println("Поток 1 захватил Resource A");
                try {
                    // Задержка для увеличения вероятности Deadlock
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                synchronized (resourceB) {
                    System.out.println("Поток 1 захватил Resource B");
                }
            }
        });

        // Поток 2 пытается захватить ресурс B, затем ресурс A
        Thread thread2 = new Thread(() -> {
            synchronized (resourceB) {
                System.out.println("Поток 2 захватил Resource B");
                try {
                    // Задержка для увеличения вероятности Deadlock
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                synchronized (resourceA) {
                    System.out.println("Поток 2 захватил Resource A");
                }
            }
        });

        thread1.start();
        thread2.start();
    }
}
```

1. **Поток 1** захватывает ```Resource A``` и затем пытается захватить ```Resource B```.
2. **Поток 2** захватывает ```Resource B``` и затем пытается захватить ```Resource A```.
3. Оба потока оказываются в состоянии ожидания друг друга, создавая **Deadlock**.

## Как предотвратить Deadlock

1. **Избегать циклических зависимостей:** Убедитесь, что все потоки захватывают ресурсы в одном и том же порядке.
2. **Использовать тайм-ауты (очень сомнительное, но решение)**: Попытайтесь захватить ресурс с тайм-аутом, чтобы
   избежать бесконечного ожидания.
3. **Минимизировать количество захватываемых ресурсов:** Ограничьте количество ресурсов, которые каждый поток может
   захватывать одновременно.
4. **Использовать высокоуровневые механизмы управления потоками:** Например, классы из
   пакета ```java.util.concurrent``` (например, ```Lock```, ```ReentrantLock``` с ```tryLock```), которые предоставляют
   более гибкие возможности управления блокировками.

# Livelock

**Livelock** — это состояние, при котором два или более потока постоянно реагируют на действия друг друга, пытаясь
избежать Deadlock, но при этом не достигая прогресса. В отличие от Deadlock, потоки в состоянии Livelock не блокируются
навсегда, но остаются в постоянном движении, не выполняя полезной работы.

## Причины возникновения Livelock

Livelock возникает, когда потоки постоянно изменяют своё состояние в ответ на действия других потоков, но ни один из них
не может продвинуться дальше. Это может произойти, если алгоритм корректировки поведения потоков не учитывает текущие
состояния или не имеет условий выхода.

## Пример Livelock (из жизни, кода не будет)

Когда вы сталкиваетесь на дороге с человеком и пытаясь разойтись отходите в одну и ту же сторону. Вы вдвоем меняете свое
состояние - делаете шаг в сторону, но в итоге никто из вас не продвигается вперед. Подобные ситуации с имитацией
деятельности, которые не продвигают не один из потоков дальше и называется **Livelock**. В отличии от компьютера вы
обладаете логикой и сможете разрешить данную ситуацию. Машине же такое неподвластно :) _Пока что..._






