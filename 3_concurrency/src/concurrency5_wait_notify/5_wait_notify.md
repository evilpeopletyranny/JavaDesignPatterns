# Конструкции wait, notify, notifyAll

В многопоточном программировании на Java методы ```wait()```, ```notify()``` и ```notifyAll()``` используются для
координации и синхронизации потоков. Они позволяют потокам взаимодействовать друг с другом, управляя доступом к общим
ресурсам и обеспечивая корректное выполнение программ.

## Основные понятия

1. **Монитор (Monitor)**: В Java каждый объект имеет монитор, который используется для синхронизации доступа к его
   синхронизированным методам или блокам кода.
2. **Блокировка (Lock)**: Когда поток входит в синхронизированный метод или блок, он захватывает монитор объекта,
   предотвращая доступ других потоков к этому объекту до освобождения блокировки.
3. **Состояние ожидания (Waiting State)**: Поток может перейти в состояние ожидания, вызывая метод wait(), освобождая
   монитор и приостанавливая своё выполнение до получения уведомления (```notify()``` или ```notifyAll()```).

# Как работают данные методы

Все методы должны использоваться только в синхронизированном методе или блоке кода. Для защиты и соблюдения данного
условия - выбрасывается исключение ```IllegalMonitor``` если данные методы вызываются все синхронизированного блока.

## Метод ```wait()```

1. Поток, вызвавший ```wait()```, переходит в состояние ожидания (waiting) и не может продолжить выполнение до тех пор,
   пока другой поток не вызовет ```notify()``` или ```notifyAll()``` на том же объекте.
2. После пробуждения поток пытается снова получить монитор объекта и продолжить выполнение с точки, на которой был
   вызван ```wait()```.

## Метод ```notify()```

Пробуждает один случайный поток, ожидающий на мониторе данного объекта.

1. Если несколько потоков находятся в состоянии ожидания на мониторе объекта, ```notify()``` выберет один из них случано
   и переведёт его в состояние готовности к выполнению (runnable)
2. Пробужденный поток должен снова получить монитор объекта, прежде чем сможет продолжить выполнение.

## Метод ```notifyAll()```

1. Все потоки, находящиеся в состоянии ожидания на мониторе объекта, переводятся в состояние готовности к выполнению.
2. Каждый пробужденный поток должен по очереди получить монитор объекта, прежде чем продолжить выполнение.

# Примеры

Примеры рассматриваются на основе паттерна "Производитель-Потребитель", где один поток (производитель) производит данные
и помещает их в общий ресурс, а другой поток (потребитель) потребляет эти данные.

## [Пример](code%2Fnotify_example%2FMain.java) использованися notify

Класс имитирующий разделяемый ресурс. Содержит методы изменения данных - ```produce()``` и чтения
данных ```consume()```.

```java
class SharedResource {
    private int data;
    private boolean available = false;

    // Метод для производителя
    public synchronized void produce(int value) {
        while (available) { // Ждём, пока ресурс будет свободен
            try {
                wait(); // Поток производитель засыпает
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        data = value;
        available = true;
        System.out.println(Thread.currentThread().getName() + " произвел: " + value);
        notify(); // Уведомляем потребителя о доступности данных
    }

    // Метод для потребителя
    public synchronized int consume() {
        while (!available) { // Ждём, пока данные будут доступны
            try {
                wait(); // Поток потребитель засыпает
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        available = false;
        System.out.println(Thread.currentThread().getName() + " потребил: " + data);
        notify(); // Уведомляем производителя о том, что ресурс свободен
        return data;
    }
}
```

---

Класс производитель - класс, который производит данные - изменяет общий ресурс.

```java
class Producer implements Runnable {
    private SharedResource shared;

    public Producer(SharedResource shared) {
        this.shared = shared;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            shared.produce(i);
            try {
                Thread.sleep(1000); // Имитация времени производства
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

---

Класс потребитель - класс, который использует общие данные

```java
class Consumer implements Runnable {
    private SharedResource shared;

    public Consumer(SharedResource shared) {
        this.shared = shared;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            shared.consume();
            try {
                Thread.sleep(1500); // Имитация времени потребления
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }
}
```

--- 

Класс демонстрирующий работу. Создаются по одному производителю и потребителю, им передается ссылка на один общий
ресурс.

```java
public class Main {
    public static void main(String[] args) {
        SharedResource shared = new SharedResource();

        // Поток производителя
        Thread producer = new Thread(new Producer(shared), "Производитель");
        // Поток потребителя
        Thread consumer = new Thread(new Consumer(shared), "Потребитель");

        producer.start();
        consumer.start();
    }
}
```

### Описание

1. **Инициализация:** Создаются два потока: ```producer``` и ```consumer```, оба работающие с одним
   экземпляром ```SharedResource```.
2. **Производство данных (```produce```):**
    - Производитель пытается произвести данные, но если ресурс уже занят (```available == true```), он засыпает,
      вызывая ```wait()```.
    - После производства данных устанавливает ```available = true``` и вызывает ```notify()```, чтобы пробудить
      потребителя.
3. **Потребление данных (```consume```):**
    - Потребитель пытается потребить данные, но если данных нет (```available == false```), он засыпает,
      вызывая ```wait()```.
    - После потребления данных устанавливает ```available = false``` и вызывает ```notify()```, чтобы пробудить
      производителя.

### Пример вывода:

```
Производитель произвел: 1
Потребитель потребил: 1
Производитель произвел: 2
Потребитель потребил: 2
Производитель произвел: 3
Потребитель потребил: 3
Производитель произвел: 4
Потребитель потребил: 4
Производитель произвел: 5
Потребитель потребил: 5
```

## [Пример](code%2Fnotify_example%2FMain.java) использованися notifyAll

Класс имитирующий разделяемый ресурс, методы ```produce(int value)``` для производителя
и ```public synchronized Integer consume()``` для потребителя. Добавлен класс ```setFinished()``` для установки флага
завершения производства.

```java
public class SharedResource {
    private int data;
    private boolean available = false;

    // Метод для производителя
    public synchronized void produce(int value) {
        while (available) { // Ждём, пока ресурс будет свободен
            try {
                wait();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        data = value;
        available = true;
        System.out.println(Thread.currentThread().getName() + " произвел: " + value);
        notify(); // Уведомляем потребителя о доступности данных
    }

    // Метод для потребителя
    public synchronized int consume() {
        while (!available) { // Ждём, пока данные будут доступны
            try {
                wait(); // Поток потребитель засыпает
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        available = false;
        System.out.println(Thread.currentThread().getName() + " потребил: " + data);
        notify(); // Уведомляем производителя о том, что ресурс свободен
        return data;
    }
}
```

---

Класс производитель - класс, который производит данные - изменяет общий ресурс.

```java
class Producer implements Runnable {
    private SharedResource shared;

    public Producer(SharedResource shared) {
        this.shared = shared;
    }

    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            shared.produce(i);
            try {
                Thread.sleep(1000); // Имитация времени производства
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        shared.setFinished(); // Устанавливаем флаг завершения после производства всех данных
        System.out.println(Thread.currentThread().getName() + " завершил производство.");
    }
}
```

---

Класс потребитель - класс, который использует общие данные

```java
class Consumer implements Runnable {
    private SharedResource shared;

    public Consumer(SharedResource shared) {
        this.shared = shared;
    }

    @Override
    public void run() {
        while (true) {
            Integer value = shared.consume();
            if (value == null) { // Проверяем, завершено ли производство
                break; // Выходим из цикла и завершаем поток
            }
            try {
                Thread.sleep(1500); // Имитация времени потребления
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
        System.out.println(Thread.currentThread().getName() + " завершил потребление.");
    }
}
```

--- 

Класс демонстрирующий работу. Создаются один производитель и 2 потребителя, им передается ссылка на один общий
ресурс. Потребители оба ждут когда производитель завершит работу, затем один из них захватывает монитор и обрабаывает
данные.

```java
public class Main {
    public static void main(String[] args) {
        SharedResource shared = new SharedResource();

        // Создаем одного производителя
        Thread producer = new Thread(new Producer(shared), "Производитель");

        // Создаем двух потребителей
        Thread consumer1 = new Thread(new Consumer(shared), "Потребитель-1");
        Thread consumer2 = new Thread(new Consumer(shared), "Потребитель-2");

        producer.start();
        consumer1.start();
        consumer2.start();

        try {
            producer.join();
            consumer1.join();
            consumer2.join();
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("Все потоки завершены. Программа завершена.");
    }
}
```

### Описание

1. **Инициализация:**
    - Создаётся один производитель (```Producer```) и два потребителя (```Consumer```).
    - Все потоки запускаются одновременно.
2. **Производство данных:**
    - Производитель производит 5 элементов (```1``` до ```5```), по одному в секунду.
    - После каждого производства вызывается ```notifyAll()```, чтобы уведомить потребителей о доступности данных.
3. **Потребление данных:**
    - Каждый потребитель пытается потребить данные.
    - Если данных нет и производство ещё продолжается, поток засыпает, вызывая ```wait()```.
    - Если производство завершено и данных больше нет (```finished == true```), метод ```consume()```
      возвращает ```null```, что сигнализирует потребителю о завершении работы.
4. **Завершение работы:**
    - После производства всех данных производитель устанавливает флаг ```finished``` и вызывает ```notifyAll()```, чтобы
      пробудить всех ожидающих потребителей.
    - Потребители, получив ```null``` из ```consume()```, выходят из цикла и завершаются.
    - Главный поток ожидает завершения всех потоков с помощью ```join()```, после чего выводит сообщение о завершении
      программы.

### Пример вывода:

```
Производитель произвел: 1
Потребитель-1 потребил: 1
Производитель произвел: 2
Потребитель-2 потребил: 2
Производитель произвел: 3
Потребитель-1 потребил: 3
Производитель произвел: 4
Потребитель-2 потребил: 4
Производитель произвел: 5
Потребитель-1 потребил: 5
Производитель завершил производство.
Потребитель-2 завершил потребление.
Потребитель-1 завершил потребление.
Все потоки завершены. Программа завершена.
```

### Особенности примера

1. Флаг завершения (```finished```):
    - Добавлен для сигнализации потребителям о том, что производитель завершил производство данных.
    - Без этого флаг ```finished``` потребители не узнают о завершении работы производителя и будут ожидать новых данных
      бесконечно.
2. Условие остоновки потребителей - Возвращение ```null``` в методе ```consume()```:
    - Когда finished равен ```true``` и данные отсутствуют, метод ```consume()``` возвращает ```null```.
    - Потребители используют это значение как сигнал для выхода из цикла и завершения работы.
3. Использование ```notifyAll()```:
    - Вместо ```notify()``` используется ```notifyAll()```, чтобы убедиться, что все ожидающие потребители получают
      уведомление о доступности данных или о завершении производства.
    - Это предотвращает ситуацию, когда один потребитель пробуждён, а другие остаются в ожидании, даже если данные уже
      обработаны.
4. Проверка условий в циклах ```while```: Потоки используют цикл ```while``` для проверки условий ожидания, что защищает
   от ложных пробуждений и обеспечивает корректное поведение при изменении условий после пробуждения.

# Советы по использованию данных конструкций

1. Всегда используйте ```wait``` внутри цикла ```while```: Это защищает от ложных пробуждений и обеспечивает проверку
   условий после пробуждения.
2. Минимизируйте область синхронизации: Синхронизируйте только необходимые блоки кода, чтобы снизить вероятность
   блокировок и повысить производительность.
3. **Предпочитайте ```notifyAll()``` в сложных сценариях**: Это помогает избежать ситуации, когда нужный поток остаётся
   в ожидании, если вызван ```notify()```, но пробуждён другой поток.
4. Избегайте вложенных блокировок и дедлоков: Проектируйте систему так, чтобы потоки не блокировали друг друга
   бесконечно, ожидая освобождения ресурсов.