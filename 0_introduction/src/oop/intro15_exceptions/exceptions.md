# Исключения

В Java исключения представляют собой объекты, которые создаются и выбрасываются (```throw```) при возникновении ошибки.
Эти объекты являются экземплярами классов, которые наследуются от класса ```Throwable```.

## Иерархия классов исключений

- ```Throwable```: Базовый класс для всех ошибок и исключений
    - ```Exception```: Класс для исключений, которые могут быть обработаны программой.
    - ```RuntimeException```: Исключения времени выполнения.
    - **Пользовательские исключения**: Ваши собственные классы исключений, наследуемые от ```Exception```.
- ```Error```: Класс для ошибок, которые не должны быть обработаны программой (например, ```OutOfMemoryError```).

## Типы исключений

### 1. Проверяемые исключения (Checked Exceptions):

- Проверяются компилятором.
- Должны быть либо обработаны с помощью блока ```try-catch```, либо объявлены в сигнатуре метода с ключевым
  словом ```throws```.

**Примеры**: ```IOException```, ```SQLException```.

### 2. Непроверяемые исключения (Unchecked Exceptions):

- Не проверяются компилятором.
- Наследуются от RuntimeException.
- Могут быть обработаны, но не обязаны.

**Примеры**: ```NullPointerException```, ```ArrayIndexOutOfBoundsException```.

### 3. Ошибки (Errors):

- Наследуются от класса ```Error```.
- Обычно не обрабатываются приложением.

**Примеры**: ```StackOverflowError```, ```OutOfMemoryError```.

## Работа с исключениями

### Генерация исключений

Чтобы сгенерировать исключение, используется ключевое слово ```throw```, за которым следует объект исключения.

```
if (denominator == 0)  throw new ArithmeticException("Деление на ноль невозможно");
```

### Обработка исключений

Для обработки исключений используются блоки ```try```, ```catch```, ```finally```.

#### Блок ```try-catch```

```
try {
    // Код, который может вызвать исключение
} catch (ExceptionType e) {
    // Обработка исключения
}
```

##### [Пример](TryCatchMain.java)

```java
public class Main {
    public static void main(String[] args) {
        try {
            int[] numbers = {1, 2, 3};
            System.out.println(numbers[5]); // Здесь возникнет исключение
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Ошибка: выход за пределы массива");
            e.printStackTrace(); // Вывод стека вызовов для отладки
        }
    }
}
```

#### Блок ```finally```

Блок ```finally``` выполняется всегда, независимо от того, было выброшено исключение или нет.

```
try {
    // Код, который может вызвать исключение
} catch (ExceptionType e) {
    // Обработка исключения
} finally {
    // Код, который выполнится в любом случае
}
```

##### [Пример](TryCatchMain.java)

```java
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class Main {
    public static void main(String[] args) {
        FileInputStream file = null;
        try {
            file = new FileInputStream("test.txt");
            // Чтение файла
        } catch (FileNotFoundException e) {
            System.out.println("Файл не найден");
        } finally {
            if (file != null) {
                try {
                    file.close();
                } catch (IOException e) {
                    System.out.println("Ошибка при закрытии файла");
                }
            }
        }
    }
}
```

#### Оператор ```throws```

Если метод может выбросить проверяемое исключение, он должен объявить это с помощью ключевого слова ```throws```.

```
public void readFile(String filename) throws IOException {
    FileInputStream file = new FileInputStream(filename);
    // Чтение файла
}
```

##### Пример

```java
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Objects;

public class FileProcessor {
    public void processFile(String filename) throws IOException {
        Objects.requireNonNull(filename, "Имя файла не должно быть null");
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            while ((line = reader.readLine()) != null) {
                // Обработка строки
                System.out.println(line);
            }
        }
    }
}
```

Java единственный язык, где требуется явно указывать в сигнатуре функции то, что она может выкинуть исключения. Такое
интересное решение могло быть связано со следующим:

##### 1. Контракт метода и его надежность

Объявление исключений в сигнатуре метода позволяет:

- **Явно указать** возможные исключительные ситуации, которые могут возникнуть при вызове метода.
- **Информировать вызывающий код** о необходимости обработки потенциальных ошибок.
- **Заставить разработчика принять решение**: обработать исключение на месте или пробросить его дальше.

##### 2. Безопасность и надежность кода

- **Компилятор контролирует** корректность обработки исключений, что уменьшает вероятность необработанных ошибок.
- **Предотвращение непредвиденных сбоев**: Заставляет разработчика осознавать возможные проблемы и принимать меры по их
  предотвращению.

##### 3. Документирование поведения метода

- **Читаемость кода**: Сигнатура метода становится более информативной, показывая, какие исключения могут быть
  выброшены.
- **Ясность контракта**: Облегчает понимание того, как правильно использовать метод и какие ошибки могут возникнуть.

## Создание собственных исключений

Вы можете создать свои собственные исключения, наследуя класс ```Exception``` или ```RuntimeException```.

```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

public class Main {
    public static void checkAge(int age) throws InvalidAgeException {
        if (age < 18) {
            throw new InvalidAgeException("Возраст должен быть не менее 18 лет");
        }
    }

    public static void main(String[] args) {
        try {
            checkAge(16);
        } catch (InvalidAgeException e) {
            System.out.println("Поймано исключение: " + e.getMessage());
        }
    }
}
```

## Лучшие практики при работе с исключениями

1. **Используйте исключения для исключительных ситуаций**:  Не используйте исключения для управления потоком выполнения
   в обычных ситуациях.
2. **Иерархия исключений**: Расширяйте существующие исключения, если это возможно, чтобы обеспечить более конкретную
   информацию об ошибке.
3. **Информативные сообщения**: Предоставляйте полезные сообщения в исключениях для облегчения отладки.
4. **Не подавляйте исключения**: Избегайте пустых блоков ```catch```; если вы ловите исключение, обрабатывайте его или
   повторно выбрасывайте.

```
catch (Exception e) {
    // Плохо: ничего не делаем, ошибка игнорируется
}
```

5. **Используйте многократные блоки ```catch```**: Для обработки разных типов исключений по-разному.

```
try {
    // Код, который может вызвать несколько типов исключений
} catch (FileNotFoundException e) {
    // Обработка FileNotFoundException
} catch (IOException e) {
    // Обработка других IOException
}
```

6. **Используйте ```try-with-resources```**: Для автоматического закрытия ресурсов, таких как файлы или соединения.

```
try (FileInputStream file = new FileInputStream("test.txt")) {
    // Чтение файла
} catch (IOException e) {
    // Обработка исключения
}
```

## Заключение

Исключения являются мощным инструментом для управления ошибками и поддержания стабильной работы приложения. Правильное
использование исключений способствует улучшению качества кода, облегчает отладку и поддержку программного обеспечения.
При разработке всегда учитывайте возможные ошибки и обрабатывайте их соответствующим образом.

## Дополнительно

[Почему](disadvantages.md) исключения не так прекрасны как кажутся на первый взгляд...